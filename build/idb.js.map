{"version":3,"sources":["builder.js","worker-model-handler.js","model.js","migration.js","db.js","idb.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACp6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"idb.js","sourcesContent":["class Builder {\n\n    constructor () {\n        this.builder = [];\n        this.indexBuilder = {};\n        this.relations = [];\n        this.tables = [];\n    }\n\n    /**\n     * Sets the index builder value as an 'and' reference\n     *\n     * @param indexName string\n     * @param value mixed\n     * @returns {Builder}\n     */\n    whereIndex(indexName, value) {\n\n        this.indexBuilder = {\n            index : indexName,\n            value : value,\n            type : 'and'\n        };\n\n        return this;\n    }\n\n    /**\n     * Sets the index builder value as an 'in' reference\n     * @param indexName\n     * @param value\n     * @returns {Builder}\n     */\n    whereIndexIn(indexName, value) {\n\n        this.indexBuilder = {\n            index : indexName,\n            value : value,\n            type : 'in'\n        };\n\n        return this;\n    }\n\n    /**\n     * Sets the index builder value with point inclusive and sets greater than check\n     * @param indexName\n     * @param value\n     * @returns {Builder}\n     */\n    indexGte(indexName, value) {\n\n        this.indexBuilder = {\n            index : indexName,\n            value : value,\n            type : 'gte'\n        };\n\n        return this;\n    }\n\n    /**\n     * Sets the index builder value with point not inclusive and sets greater than check\n     * @param indexName\n     * @param value\n     * @returns {Builder}\n     */\n    indexGt(indexName, value) {\n\n        this.indexBuilder = {\n            index : indexName,\n            value : value,\n            type : 'gt'\n        };\n\n        return this;\n    }\n\n    /**\n     * Sets the index builder value with point inclusive and sets less than check\n     * @param indexName\n     * @param value\n     * @returns {Builder}\n     */\n    indexLte(indexName, value) {\n\n        this.indexBuilder = {\n            index : indexName,\n            value : value,\n            type : 'lte'\n        };\n\n        return this;\n    }\n\n    /**\n     * Sets the index builder value with point not inclusive and sets less than check\n     *\n     * @param indexName\n     * @param value\n     * @returns {Builder}\n     */\n    indexLt(indexName, value) {\n\n        this.indexBuilder = {\n            index : indexName,\n            value : value,\n            type : 'lt'\n        };\n\n        return this;\n    }\n\n    /**\n     * Sets the index builder value with points inclusive and sets range between them\n     * @param indexName\n     * @param lower\n     * @param upper\n     * @returns {Builder}\n     */\n    indexBetween(indexName, lower, upper) {\n\n        this.indexBuilder = {\n            index : indexName,\n            value : [lower, upper],\n            type : 'between'\n        };\n\n        return this;\n    }\n\n    whereIn(attributeName, value) {\n        this.builder.push({\n            attribute : attributeName,\n            value : value,\n            type : 'in'\n        });\n\n        return this;\n    }\n\n    where(attributeName, value) {\n        this.builder.push({\n            attribute : attributeName,\n            value : value,\n            type : 'and'\n        });\n\n        return this;\n    }\n\n\n    gte(attributeName, value) {\n        this.builder.push({\n            attribute : attributeName,\n            value : value,\n            type : 'gte'\n        });\n\n        return this;\n    }\n\n    gt(attributeName, value) {\n        this.builder.push({\n            attribute : attributeName,\n            value : value,\n            type : 'gt'\n        });\n\n        return this;\n    }\n\n    lte(attributeName, value) {\n        this.builder.push({\n            attribute : attributeName,\n            value : value,\n            type : 'lte'\n        });\n\n        return this;\n    }\n\n    lt(attributeName, value) {\n        this.builder.push({\n            attribute : attributeName,\n            value : value,\n            type : 'lt'\n        });\n\n        return this;\n    }\n\n    between(attributeName, upper, lower) {\n        uppper = parseFloat(upper);\n        lower = parseFloat(lower);\n\n        if(isNaN(upper) || isNaN(lower)){\n            throw \"Between is only for numeric values\";\n        }\n\n        this.builder.push({\n            attribute : attributeName,\n            value : [upper, lower],\n            type : 'between'\n        });\n\n        return this;\n    }\n\n    relation(modelName, type, localKey, foreignKey, func, primary) {\n        this.tables.push(modelName);\n\n        this.relations.push({\n            modelName : modelName,\n            func : func,\n            localKey : localKey,\n            foreignKey : foreignKey,\n            type : type,\n            primary : primary\n        });\n\n        return this;\n    }\n\n    static get helpers() {\n\n        return {\n\n            checkNestedAttribute (attributeString, value, condition) {\n                return condition == Model.helpers.getNestedAttribute(attributeString, value)\n            },\n\n            getNestedAttribute(attributeString, value) {\n                let attributes = attributeString.split('.');\n                let i;\n                let content = value;\n\n                for(i = 0; i < attributes.length; i++) {\n                    if(content[attributes[i]] === undefined){\n                        return undefined;\n                    }\n\n                    content = content[attributes[i]];\n                }\n\n                return content;\n            },\n\n            replaceNestedValues(attributes, value) {\n                for(let attribute in attributes) {\n                    value[attribute] = attributes[attribute];\n                }\n\n                return value;\n            },\n        };\n\n    }\n\n    static get RELATIONS() {\n        return {\n            hasOne : 'hasOne',\n            hasMany : 'hasMany'\n        }\n    }\n}","class WorkerModelHandler extends Builder{\n\n    constructor(modelName, workerContent) {\n        super();\n\n        this.name = modelName;\n        this.worker = workerContent;\n        this.setUpHandler();\n        this.tables = [modelName];\n    }\n\n    /**\n     * Finds the model by id\n     * @param id\n     * @returns {Promise}\n     */\n    find(id) {\n        let model = this;\n\n        return new Promise((resolve, reject) => {\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'find', handler);\n            model.on(timestamp, 'find-error', errorHandler);\n\n            model.send(id, timestamp, 'find');\n\n            /**\n             * normal success handler\n             * @param e\n             */\n            function handler(e) {\n                model.removeListener(timestamp, 'find', handler);\n                model.removeListener(timestamp, 'find-error', errorHandler());\n\n                resolve(e.detail);\n            }\n\n            /**\n             * Error handler case\n             * @param e\n             */\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'find', errorHandler);\n                model.removeListener(timestamp, 'find-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Function fetches list of result matching the criteria\n     * @returns {Promise}\n     */\n    get() {\n        let model = this;\n        return new Promise((resolve, reject) => {\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'get', handler);\n            model.on(timestamp, 'get-error', errorHandler);\n\n            model.send({\n                tables : model.tables,\n                builder : model.builder,\n                indexBuilder : model.indexBuilder,\n                relations : model.relations\n            }, timestamp, 'get');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'get', handler);\n                model.removeListener(timestamp, 'get-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'get', errorHandler);\n                model.removeListener(timestamp, 'get-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Function fetches list of result matching the criteria\n     * @returns {Promise}\n     */\n    first() {\n        let model = this;\n        return new Promise((resolve, reject) => {\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'first', handler);\n            model.on(timestamp, 'first-error', errorHandler);\n\n            model.send({\n                tables : model.tables,\n                builder : model.builder,\n                indexBuilder : model.indexBuilder,\n                relations : model.relations\n            }, timestamp, 'first');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'first', handler);\n                model.removeListener(timestamp, 'first-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'first', errorHandler);\n                model.removeListener(timestamp, 'first-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Creates a record\n     * @param data\n     * @returns {Promise}\n     */\n    create(data) {\n        let model = this;\n        return new Promise((resolve, reject) => {\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'create', handler);\n            model.on(timestamp, 'create-error', errorHandler);\n\n            model.send(data, timestamp, 'create');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'create', handler);\n                model.removeListener(timestamp, 'create-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'create', errorHandler);\n                model.removeListener(timestamp, 'create-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Creates multiple records\n     * @param data Array\n     * @returns {Promise}\n     */\n    createMultiple(data) {\n        let model = this;\n        return new Promise((resolve, reject) => {\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'createMultiple', handler);\n            model.on(timestamp, 'createMultiple-error', errorHandler);\n\n            model.send(data, timestamp, 'createMultiple');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'createMultiple', handler);\n                model.removeListener(timestamp, 'createMultiple-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'createMultiple', errorHandler);\n                model.removeListener(timestamp, 'createMultiple-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Function updates the various records with matching values\n     * @param data\n     * @returns {Promise}\n     */\n    update(data) {\n        let model = this;\n        return new Promise((resolve, reject) => {\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'update', handler);\n            model.on(timestamp, 'update-error', errorHandler);\n\n            model.send(data, timestamp, 'update');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'update', handler);\n                model.removeListener(timestamp, 'update-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'update', errorHandler);\n                model.removeListener(timestamp, 'update-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Function updates the record at the given id\n     * @param id\n     * @param data\n     * @returns {Promise}\n     */\n    save(id, data) {\n        let model = this;\n        return new Promise((resolve, reject) => {\n\n            let timestamp = Date.now();\n            let content = {\n                id : id,\n                data : data\n            };\n\n            model.on(timestamp, 'save', handler);\n            model.on(timestamp, 'save-error', errorHandler);\n            model.send(content, timestamp, 'save');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'save', handler);\n                model.removeListener(timestamp, 'save-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'save', errorHandler);\n                model.removeListener(timestamp, 'save-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Function deletes the entries at the given point\n     * @param id\n     * @returns {Promise}\n     */\n    destroyId(id) {\n        let model = this;\n        return new Promise((resolve, reject) => {\n\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'destroyId', handler);\n            model.on(timestamp, 'destroyId-error', errorHandler);\n            model.send(id, timestamp, 'destroyId');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'destroyId', handler);\n                model.removeListener(timestamp, 'destroyId-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'destroyId', errorHandler);\n                model.removeListener(timestamp, 'destroyId-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Function deletes the entries\n     * @returns {Promise}\n     */\n    destroy() {\n        let model = this;\n        return new Promise((resolve, reject) => {\n\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'destroy', handler);\n            model.on(timestamp, 'destroy-error', errorHandler);\n            model.send({}, timestamp, 'destroy');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'destroy', handler);\n                model.removeListener(timestamp, 'destroy-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'destroy', errorHandler);\n                model.removeListener(timestamp, 'destroy-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Function counts the number of records\n     * @returns {Promise}\n     */\n    count() {\n        let model = this;\n        return new Promise((resolve, reject) => {\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'count', handler);\n            model.on(timestamp, 'count-error', errorHandler);\n\n            model.send({}, timestamp, 'count');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'count', handler);\n                model.removeListener(timestamp, 'count-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'count', errorHandler);\n                model.removeListener(timestamp, 'count-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    average(attribute) {\n        let model = this;\n        return new Promise((resolve, reject) => {\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'average', handler);\n            model.on(timestamp, 'average-error', errorHandler);\n\n            model.send(attribute, timestamp, 'average');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'average', handler);\n                model.removeListener(timestamp, 'average-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'average', errorHandler);\n                model.removeListener(timestamp, 'average-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Reduce function is called with each passing iterator value and reduced value is returned\n     * @param func\n     * @param defaultCarry\n     * @returns {Promise}\n     */\n    reduce(func, defaultCarry) {\n        let model = this;\n        return new Promise((resolve, reject) => {\n            let timestamp = Date.now();\n\n            model.on(timestamp, 'reduce', handler);\n            model.on(timestamp, 'reduce-error', errorHandler);\n\n            let data = {\n                func : func,\n                defaultCarry : defaultCarry\n            };\n\n            model.send(data, timestamp, 'reduce');\n\n            function handler(e) {\n                model.removeListener(timestamp, 'reduce', handler);\n                model.removeListener(timestamp, 'reduce-error', errorHandler);\n\n                resolve(e.detail);\n            }\n\n            function errorHandler(e) {\n                model.removeListener(timestamp, 'reduce', errorHandler);\n                model.removeListener(timestamp, 'reduce-error', handler);\n                reject(e.detail);\n            }\n\n        });\n    }\n\n    /**\n     * Communicates to webworker\n     * @param data\n     * @param timestamp\n     * @param action\n     */\n    send(data, timestamp, action) {\n        let model = this;\n\n        let detail = JSON.stringify(data, (key, value) => {\n            return (typeof value === 'function' ) ? value.toString() : value;\n        });\n\n        let e = {\n            detail : detail,\n            action : action,\n            timestamp : timestamp,\n            model : model.name\n        };\n\n        model.worker.postMessage(e);\n    }\n\n    /**\n     * Sets up basic handler settings to receive messages from worker\n     */\n    setUpHandler () {\n        let model = this;\n\n        //general handler to act up messages sent from web worker\n        model.worker.onmessage = function(e) {\n            let data = e.data.detail;\n            model.emit(data, e.data.timestamp, e.data.action);\n\n        }\n    }\n\n    /**\n     * Normal emit event on window.document\n     *\n     * @param data\n     * @param timestamp\n     * @param action\n     */\n    emit (data, timestamp, action) {\n        let model = this;\n        let e = new CustomEvent('idb:worker:' + model.modeName + ':' + timestamp + ':' + action, {\n            detail : data\n        });\n\n        window.document.dispatchEvent(e);\n    }\n\n    /**\n     * Removes event listener from window.document\n     *\n     * @param timestamp\n     * @param action\n     * @param func\n     */\n    removeListener(timestamp, action, func) {\n        window.document.removeEventListener('idb:worker:' + this.modeName + ':' + timestamp + ':' + action, func);\n    }\n\n    /**\n     * Listens events on window.document\n     *\n     * @param timestamp date time stamp\n     * @param action action name\n     * @param func function to be executed\n     */\n    on(timestamp, action, func) {\n        window.document.addEventListener('idb:worker:' + this.modeName + ':' + timestamp + ':' + action, func);\n    }\n}","class Model extends Builder{\n\n    constructor(db, idbKey, modelName, primary){\n        super();\n\n        this.name = modelName;\n        this.db = db;\n        this.primary = primary;\n        this.tables = [this.name];\n        this.idbKey = idbKey;\n        this.hasIdbKey = this.idbKey ? true : false;\n        this.transaction = null;\n        this.attributes = {};\n    }\n\n    /**\n     * Finds the result on the primary key defined\n     * @param id\n     * @returns {Promise}\n     */\n    find(id) {\n        let model = this;\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READONLY);\n            let obj = transaction.objectStore(model.name);\n            let request = obj.get(id);\n            \n            request.onsuccess = function (e) {\n                resolve(e.target.result);\n            };\n\n            request.onerror = function (e) {\n                reject(e);\n            };\n\n        });\n    }\n\n    /**\n     * Searches for first value in database and returns that\n     * @returns {Promise}\n     */\n    first() {\n        let model = this;\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READONLY);\n            let obj = transaction.objectStore(model.name);\n            let result = null;\n            let request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                let cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        let relationsCompleted = 0;\n\n                        result = cursor.value;\n\n                        if(model.relations.length > 0 && (result !== null || result !== undefined)){\n\n\n                            model.relations.forEach((relation) => {\n\n                                let relationRequest = model.getRelationships(relation, model.transaction, model.getMainResult(result, relation.localKey, false), false);\n\n                                relationRequest.then((relationResult) => {\n\n                                    relationsCompleted++;\n\n                                    let defaultValue = model.getDefaultRelationValue(relation.type);\n                                    result[relation.modelName] = result[relation.modelName] || defaultValue;\n\n                                    switch (relation.type) {\n                                        case Model.RELATIONS.hasOne :\n                                            if (relationResult !== undefined) {\n                                                result[relation.modelName] = relationResult[relation.foreignKey] == result[relation.localKey] ? relationResult : result[relation.modelName];\n                                            }\n\n                                            break;\n                                        case Model.RELATIONS.hasMany :\n                                            if (relationResult.length > 0) {\n                                                result[relation.modelName] = relationResult.filter((relationResultItem) => {\n                                                    return relationResultItem[relation.foreignKey] == result[relation.localKey];\n                                                });\n                                            }\n                                            break;\n                                    }\n\n                                    if (relationsCompleted == model.relations.length) {\n                                        resolve(result);\n                                    }\n\n                                }).catch((err) => {\n                                    reject(err);\n                                });\n                            });\n                        }else{\n                            resolve(cursor.value);\n                            return false;\n                        }\n                    }else{\n                        cursor.continue();\n                    }\n\n                }else{\n                    resolve(result);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     * Function searches throughout the database and returns a array of result\n     * @returns {Promise}\n     */\n    get() {\n        let model = this;\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READONLY);\n            let obj = transaction.objectStore(model.name);\n            let result = [];\n            let request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                let cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        result.push(cursor.value);\n                    }\n                    cursor.continue();\n\n                }else{\n                    let mainResult, relationsCompleted = 0;\n\n                    if(model.relations.length > 0 && result.length > 0){\n\n\n                        model.relations.forEach((relation) => {\n\n                            let relationRequest = model.getRelationships(relation, model.transaction, model.getMainResult(result, relation.localKey, true), true);\n\n                            relationRequest.then((relationResult) => {\n\n                                relationsCompleted++;\n\n                                result = result.map(item => {\n\n                                    let defaultValue = model.getDefaultRelationValue(relation.type);\n                                    item[relation.modelName] = item[relation.modelName] || defaultValue;\n\n                                    switch (relation.type) {\n                                        case Model.RELATIONS.hasOne :\n                                            if(relationResult !== undefined) {\n                                                item[relation.modelName] = relationResult[relation.foreignKey] == item[relation.localKey] ? relationResult : item[relation.modelName];\n                                            }\n\n                                            break;\n                                        case Model.RELATIONS.hasMany :\n                                            if(relationResult.length > 0) {\n                                                item[relation.modelName] = relationResult.filter((relationResultItem) => {\n                                                    return relationResultItem[relation.foreignKey] == item[relation.localKey];\n                                                });\n                                            }\n                                            break;\n                                    }\n\n                                    return item;\n                                });\n\n                                if(relationsCompleted == model.relations.length){\n                                    resolve(result);\n                                }\n\n                            }).catch((err) => {\n                                reject(err);\n                            })\n                        });\n                    }else{\n                        resolve(result);\n                    }\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     * Function creates a single record\n     * @param data\n     * @returns {Promise}\n     */\n    create(data) {\n        let model = this;\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READWRITE);\n\n            let obj = transaction.objectStore(model.name);\n\n            data.createdAt = Date.now();\n            data.updatedAt = Date.now();\n\n            let request = obj.add(data);\n\n            request.onsuccess = function (e) {\n                data[model.primary] = e.target.result;\n                resolve(data);\n            };\n\n            request.onerror = function (e) {\n                reject(e);\n            };\n        });\n\n    }\n\n    /**\n     * Function creates list of records passed\n     * @param dataRecords\n     * @returns {Promise}\n     */\n    createMultiple (dataRecords) {\n        let model = this;\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READWRITE);\n\n            let obj = transaction.objectStore(model.name);\n            let createdAt = Date.now();\n            let updatedAt = Date.now();\n            let result = [];\n\n            dataRecords.forEach((data) => {\n                data.createdAt = createdAt;\n                data.updatedAt = updatedAt;\n\n                let request = obj.add(data);\n\n                request.onerror = function(e) {\n                    reject(e);\n                };\n\n                request.onsuccess = function(e) {\n                    data[model.primary] = e.target.result;\n\n                    result.push(data);\n\n                    if(result.length === dataRecords.length){\n                        resolve(result);\n                    }\n                };\n            })\n        });\n    }\n\n    /**\n     * Function updates the various records with matching values\n     * @param data\n     * @returns {Promise}\n     */\n    update(data) {\n\n        let model = this;\n        let updatedAt = Date.now();\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READWRITE);\n            let obj = transaction.objectStore(model.name);\n            let request, totalRecordsBeingUpdated = 0, totalRecordsUpdated = 0;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                let cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        totalRecordsBeingUpdated++;\n\n                        let id = cursor.value[model.primary];\n                        let createdAt = cursor.value.createdAt;\n\n                        let result = Model.helpers.replaceNestedValues(data, cursor.value);\n                        result[model.primary] = id;\n                        result.createdAt = createdAt;\n                        result.updatedAt = updatedAt;\n\n                        let updateRequest = cursor.update(result);\n\n                        updateRequest.onsuccess = function() {\n                            totalRecordsUpdated++;\n\n                            if(totalRecordsUpdated === totalRecordsBeingUpdated){\n                                resolve(true);\n                            }\n                        };\n\n                        updateRequest.onerror = function(err) {\n                            transaction.abort();\n                            reject(err);\n                        };\n\n                    }\n                    cursor.continue();\n\n                }else{\n                    resolve();\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     * Function updates the record at the given id\n     * @param id\n     * @param data\n     * @returns {Promise}\n     */\n    save(id, data) {\n        let model = this;\n        let updatedAt = Date.now();\n\n        return new Promise((resolve, reject) => {\n\n            model.find(id).then((result) => {\n\n                if(!result){\n                    reject('No record found');\n                }\n\n                let transaction = model.getTransaction(model.tables, Model.READWRITE, true);\n                let obj = transaction.objectStore(model.name);\n\n                let id = result[model.primary];\n                let createdAt = result.createdAt;\n\n                result = Model.helpers.replaceNestedValues(data, result);\n                result[model.primary] = id;\n                result.createdAt = createdAt;\n                result.updatedAt = updatedAt;\n\n                let request = obj.put(result);\n\n                request.onsuccess = function () {\n                    resolve(true);\n                };\n\n                request.onerror = function(e) {\n                    reject(e);\n                }\n            }).catch((err) => {\n                reject(err);\n            });\n\n        });\n    }\n\n    /**\n     * Function deletes the entries at the given point\n     * @param id\n     * @returns {Promise}\n     */\n    destroyId(id) {\n        let model = this;\n\n\n        return new Promise((resolve, reject) => {\n            model.find(id).then((result) => {\n\n                if(!result){\n                    reject('result at id does not exists');\n                }\n\n                let transaction = model.getTransaction(model.tables, Model.READWRITE, true);\n                let obj = transaction.objectStore(model.name);\n                let request = obj.delete(id);\n\n                request.onsuccess = function (e) {\n                    resolve(e.target.result);\n                };\n\n                request.onerror = function (e) {\n                    reject(e);\n                };\n            }).catch(err => {\n                reject(err);\n            });\n\n\n        });\n    }\n\n    /**\n     * Function deletes the entries\n     * @returns {Promise}\n     */\n    destroy() {\n        let model = this;\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READWRITE);\n            let obj = transaction.objectStore(model.name);\n            let request, totalRecordsBeingDeleted = 0, totalRecordsDeleted = 0;\n\n            if (model.indexBuilder.type) {\n                request = model.getIndexResult(obj);\n            } else {\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                let cursor = e.target.result;\n\n                if (cursor) {\n                    if (model.checkBuilderValue(cursor.value)) {\n                        totalRecordsBeingDeleted++;\n\n                        let deleteRequest = cursor.delete();\n\n                        deleteRequest.onsuccess = function () {\n                            totalRecordsDeleted++;\n\n                            if (totalRecordsDeleted === totalRecordsBeingDeleted) {\n                                resolve(true);\n                            }\n                        };\n\n                        deleteRequest.onerror = function (err) {\n                            transaction.abort();\n                            reject(err);\n                        };\n\n                    }\n                    cursor.continue();\n\n                } else {\n                    resolve();\n                }\n            };\n\n            request.onerror = function (e) {\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     * Function counts the number of records\n     * @returns {Promise}\n     */\n    count() {\n        let model = this;\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READONLY);\n            let obj = transaction.objectStore(model.name);\n            let result = 0;\n            let request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                let cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        result++;\n                    }\n\n                    cursor.continue();\n\n                }else{\n                    resolve(result);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     * Function averages the numeric value at the given point\n     * @param attribute\n     * @returns {Promise}\n     */\n    average (attribute) {\n        let model = this;\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READONLY);\n            let obj = transaction.objectStore(model.name);\n            let result = 0, totalRecords = 0;\n            let request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                let cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        totalRecords++;\n                        let tempResult = Model.helpers.getNestedAttribute(attribute, cursor.value);\n                        tempResult = parseFloat(tempResult);\n                        tempResult = isNaN(tempResult) ? 0 : tempResult;\n                        result += tempResult;\n                    }\n\n                    cursor.continue();\n\n                }else{\n                    resolve(result/totalRecords);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     * Reduce function is called with each passing iterator value and reduced value is returned\n     * @param func\n     * @param defaultCarry\n     * @returns {Promise}\n     */\n    reduce (func, defaultCarry) {\n        let model = this;\n\n        if(typeof func !== 'function'){\n            throw \"Parameter should be a function type\";\n        }\n\n        return new Promise((resolve, reject) => {\n            let transaction = model.getTransaction(model.tables, Model.READONLY);\n            let obj = transaction.objectStore(model.name);\n            let result = defaultCarry;\n            let request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                let cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        result = func(cursor.value, result);\n                    }\n\n                    cursor.continue();\n\n                }else{\n                    resolve(result);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     * Sets the index search criteria\n     * @param objectStore\n     * @returns {*}\n     */\n    getIndexResult(objectStore) {\n        let builder = this;\n        let range;\n        let index;\n\n\n        if(!builder.indexBuilder.type) {\n            return objectStore.openCursor();\n        }\n\n        if(builder.indexBuilder.index !== builder.primary){\n            index = objectStore.index(builder.indexBuilder.index);\n        }else{\n            index = objectStore;\n        }\n\n        switch (builder.indexBuilder.type) {\n            case 'and' :\n                range = builder.idbKey.only(builder.indexBuilder.value);\n                break;\n\n            case 'in' :\n                builder.whereIn(builder.indexBuilder.index, builder.indexBuilder.value);\n                let values = builder.indexBuilder.value.sort();\n                range = builder.idbKey.bound(values[0], values[values.length - 1], false, false);\n                break;\n\n            case 'gte' :\n                range = builder.idbKey.lowerBound(builder.indexBuilder.value, false);\n                break;\n\n            case 'gt' :\n                range = builder.idbKey.lowerBound(builder.indexBuilder.value, true);\n                break;\n\n            case 'lte' :\n                range = builder.idbKey.upperBound(builder.indexBuilder.value, false);\n                break;\n\n            case 'lt' :\n                range = builder.idbKey.lowerBound(builder.indexBuilder.value, true);\n                break;\n\n            case 'between' :\n                range = builder.idbKey.bound(builder.indexBuilder.value[0], builder.indexBuilder.value[1], false, false);\n                break;\n            default :\n                throw 'Invalid builder type found';\n        }\n\n        return index.openCursor(range);\n    }\n\n    /**\n     * Checks common search criteria other than the index values\n     * @param value\n     * @returns {boolean}\n     */\n    checkBuilderValue(value) {\n        let builder = this;\n        let result = true;\n        let i,j;\n        for (i = 0; i < builder.builder.length; i++){\n\n            let condition = builder.builder[i];\n            switch(condition.type){\n\n                case 'and' : //case for one to one search\n                    if(!Model.helpers.checkNestedAttribute(condition.attribute, value, condition.value)){\n                        return false;\n                    }\n                    break;\n\n                case 'in' : //case for list search\n                    let tempCheck = false;\n                    for(j = 0; j < condition.value.length; j++) {\n                        result = Model.helpers.checkNestedAttribute(condition.attribute, value, condition.value[j]);\n                        if(result !== undefined && result !== false) {\n                            tempCheck = true;\n                        }\n                    }\n\n                    if(!tempCheck){\n                        return false;\n                    }\n\n                    result = true;\n\n                    break;\n\n                case 'gte' : //case for checking the value is greater than or is equal to the same\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result < condition.value){\n                        return false;\n                    }\n\n                    result = true;\n                    break;\n\n                case 'gt' : //case for checking the value is greater than the same\n\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result <= condition.value){\n                        return false;\n                    }\n\n                    result = true;\n                    break;\n\n                case 'lte' : //case for checking the value is less than or is equal to the same\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result > condition.value){\n                        return false;\n                    }\n                    result = true;\n                    break;\n\n                case 'lt' : //case for checking the value is less than the same\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result >= condition.value){\n                        return false;\n                    }\n                    result = true;\n                    break;\n\n                case 'between' : //case for checking the value is between the given range(ONLY WORKS FOR NUMERIC)\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(condition.value[0] >= result && condition.value[1] <= result){\n                        return false\n                    }\n                    result = true;\n                    break;\n\n                default:\n                    result = true;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Creates a transaction\n     * @param tables\n     * @param mode\n     */\n    createTransaction(tables, mode) {\n        this.transaction = this.db.transaction(tables, mode)\n    }\n\n    /**\n     * Sets IDBTransaction obejct to current model scope\n     * @param transaction\n     */\n    setTransaction(transaction) {\n        this.transaction = transaction\n    }\n\n    /**\n     * Returns the IDBTransaction object set in current scope\n     * @param {Array} tables\n     * @param {String} mode\n     * @param {boolean} overwrite\n     * @returns {*|null}\n     */\n    getTransaction(tables, mode, overwrite) {\n        overwrite = overwrite === undefined ? false : overwrite;\n\n        if(!this.transaction || overwrite === true) {\n            this.createTransaction(tables, mode);\n        }\n\n        return this.transaction;\n    }\n\n    /**\n     * Returns the array or direct key value against the input give for the key specified\n     * @param result\n     * @param key\n     * @param isArray\n     * @returns {*}\n     */\n    getMainResult (result, key, isArray) {\n        if(isArray){\n            return result.map((item) => {\n                return item[key];\n            });\n        }else{\n            return result[key];\n        }\n    }\n\n    /**\n     * Searches for relationships assigned with builder and fetches them\n     * @param relation\n     * @param transaction\n     * @param mainResult\n     * @param isArray\n     * @returns {Promise}\n     */\n    getRelationships (relation, transaction, mainResult, isArray) {\n\n        isArray = isArray || false;\n\n        let model = this;\n        let primary = relation.primary || 'id';\n\n        /**\n         * @var Model relationModel\n         */\n        let relationModel = new Model(model.db, model.idbKey, relation.modelName, relation.primary);\n\n        //setting the relation transaction same as parent transaction\n        relationModel.setTransaction(transaction);\n\n        //if a secondry builder function was defined\n        if(relation.func){\n            let tempBuilder = new Builder();\n\n            tempBuilder = relation.func(tempBuilder);\n\n            relationModel.tables = tempBuilder.tables;\n            relationModel.tables.push(relationModel.name);\n            relationModel.relations = tempBuilder.relations;\n            relationModel.builder = tempBuilder.builder;\n        }\n\n        //checking type of parent result\n        if(isArray){\n            relationModel.whereIndexIn(relation.foreignKey, mainResult);\n        }else{\n            relationModel.whereIndex(relation.foreignKey, mainResult);\n        }\n\n        return new Promise((relationResolve, relationReject) => {\n\n            let result;\n\n            //if relation type mentioned\n            switch (relation.type) {\n                case Model.RELATIONS.hasOne :\n                    result = relationModel.first();\n                    break;\n                case Model.RELATIONS.hasMany :\n                    result = relationModel.get();\n                    break;\n                default :\n                    throw \"Invalid relation type provided\";\n            }\n\n            result.then(r => {\n                relationResolve(r);\n            }).catch(err => {\n                relationReject(err);\n            });\n\n        });\n    }\n\n    /**\n     * Gets the default value of result. Null for hasOne and array for hasMany\n     * @param type\n     * @returns {*}\n     */\n    getDefaultRelationValue(type) {\n    switch (type) {\n        case Model.RELATIONS.hasOne :\n            return null;\n        case Model.RELATIONS.hasMany :\n            return [];\n        default :\n            return null;\n    }\n}\n\n\n    /**\n     * Readwrite parameter of indexedDB\n     * @return {string}\n     */\n    static get READWRITE() {\n        return \"readwrite\";\n    }\n\n    /**\n     * Readonly parameter of indexedDB\n     * @return {string}\n     */\n    static get READONLY() {\n        return \"readonly\";\n    }\n\n}\n","class Migration {\n    constructor(db, transaction, migrations) {\n        /**\n         * @var IDBDatabase db\n         */\n        this.db = db;\n        this.migrations = migrations;\n        this.objectStores = [];\n\n        /**\n         * @var IDBTransaction transaction\n         */\n        this.transaction = transaction;\n    }\n\n    createStore(schema) {\n        let mig = this;\n        let primary = schema.primary || 'id';\n\n        let objectStore = mig.db.createObjectStore(schema.name, {keyPath: primary, autoIncrement: true});\n        mig.objectStores.push(objectStore);\n\n        if (schema.columns) {\n            schema.columns.forEach((column) => mig.makeIndex(column, objectStore));\n        }\n\n\n    }\n\n    run() {\n        let mig = this;\n\n        mig.migrations.forEach((schema) => {\n            if(mig.db.objectStoreNames.contains(schema.name)){\n\n                if(schema.drop){\n                    mig.db.deleteObjectStore(schema.name);\n                }else{\n                    mig.updateStore(schema);\n                }\n\n\n            }else{\n                mig.createStore(schema);\n            }\n        });\n    }\n\n    makeIndex(column, objectStore) {\n        column.attributes = column.attributes || {};\n        column.index = column.index || column.name;\n        objectStore.createIndex(column.name, column.index, column.attributes);\n    }\n\n    updateStore(schema) {\n        let mig = this;\n\n        let objectStore = mig.transaction.objectStore(schema.name);\n\n        if (schema.columns) {\n\n            schema.columns.forEach((column) => {\n                if(!objectStore.indexNames.contains(column.name)){\n                    mig.makeIndex(column, objectStore)\n                }\n            });\n        }\n\n        if(schema.dropColumns) {\n            schema.dropColumns.forEach((column) => {\n                if(objectStore.indexNames.contains(column)){\n                    mig.dropIndex(column, objectStore)\n                }\n            });\n        }\n    }\n\n    dropIndex(columnName, objectStore) {\n        debugger;\n        objectStore.deleteIndex(columnName);\n    }\n\n}\n","class DB {\n\n    constructor(idb, idbKey, settings, useWebWorker, pathToWebWorker) {\n        this.db = idb;\n        this.idbKey = idbKey;\n        this.settings = settings;\n        this.useWebWorker = useWebWorker || false;\n        this.isWebWorker = false;\n        this.pathToWebWorker = pathToWebWorker;\n    }\n\n    /**\n     * Initializes database connection with indexedDB\n     *\n     * @returns {Promise}\n     */\n    connect() {\n        let db = this;\n        return new Promise((resolve, reject) => {\n\n            if(db.useWebWorker){\n                db.createWorkerHandler(resolve, reject);\n            }else{\n                db.createNormalHandler(resolve, reject);\n            }\n        });\n    }\n\n    /**\n     * Destroys/Deletes the databaase\n     * @param dbName\n     */\n    destroy(dbName) {\n        console.info('database ' + dbName + ' deleted');\n        this.db.deleteDatabase(dbName);\n    }\n\n    /**\n     * Creates connection in web worker space and if web worker fails\n     * then creates normal database connection instance\n     * @param resolve\n     * @param reject\n     */\n    createWorkerHandler (resolve, reject) {\n        let db = this;\n        try{\n            let worker = new window.Worker(db.pathToWebWorker);\n            let models = {};\n            let timestamp = Date.now();\n\n            worker.postMessage({\n                detail : JSON.stringify(db.settings),\n                action : 'initialize',\n                timestamp : timestamp\n            });\n            \n            worker.onmessage = function (e) {\n                if(e.data.action === 'initialize' && e.data.timestamp === timestamp) {\n                    if (e.data.detail === true) {\n                        db.settings.migrations.forEach((schema) => {\n                            Object.defineProperty(models, schema.name, {\n                                get() {\n                                    return new WorkerModelHandler(schema.name, worker, window);\n                                }\n                            });\n                        });\n\n                        db.isWebWorker = true;\n                        resolve(models);\n                    } else {\n                        db.createNormalHandler(resolve, reject);\n                    }\n                }\n            }\n\n        }catch (e) {\n            reject(e);\n        }\n\n    }\n\n    /**\n     * Creates normal database instance and models\n     * @param resolve\n     * @param reject\n     */\n    createNormalHandler (resolve, reject) {\n        let db = this;\n\n        let request = this.db.open(this.settings.dbName, this.settings.dbVersion);\n\n        request.onupgradeneeded = function (e) {\n            let mig = new Migration(e.target.result, e.target.transaction, db.settings.migrations);\n            mig.run();\n        };\n\n        request.onerror = function (e) {\n            reject(e);\n        };\n\n        request.onsuccess = function (e) {\n            let models = {};\n\n            db.settings.migrations.forEach((schema) => {\n                let primary = schema.primary || 'id';\n                Object.defineProperty(models, schema.name, {\n                    get() {\n                        return new Model(e.target.result, db.idbKey, schema.name, primary);\n                    }\n                });\n            });\n\n            resolve(models);\n        };\n    }\n}","window.idb = function (settings, useWebWorker, pathToWebWorker){\n    \"use strict\";\n\n    useWebWorker = useWebWorker === undefined ? true : useWebWorker;\n\n    let idb = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n    let idbKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n    if(!idb){\n        throw \"IndexedDB not supported\";\n    }\n\n    if(!checkSettingsConfig(settings)){\n        throw \"settings parameter is incorrectly structured\";\n    }\n\n    return new DB(idb, idbKeyRange, settings, checkWebWorker(), pathToWebWorker);\n\n    function checkSettingsConfig(settings) {\n        return true;\n    }\n\n    function checkWebWorker(){\n        if(!useWebWorker) {\n            return false;\n        }\n\n        return (window.Blob && window.Worker);\n    }\n\n};\n"]}