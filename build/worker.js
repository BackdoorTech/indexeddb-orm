/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

eval("var DB = function DB(idb, idbKey, settings, useWebWorker, pathToWebWorker) {\n    this.db = idb;\n    this.idbKey = idbKey;\n    this.settings = settings;\n    this.useWebWorker = useWebWorker || false;\n    this.isWebWorker = false;\n    this.pathToWebWorker = pathToWebWorker;\n};\n\n/**\n * Initializes database connection with indexedDB\n *\n * @returns {Promise}\n */\nDB.prototype.connect = function connect () {\n    var db = this;\n    return new Promise(function (resolve, reject) {\n\n        if(db.useWebWorker){\n            db.createWorkerHandler(resolve, reject);\n        }else{\n            db.createNormalHandler(resolve, reject);\n        }\n    });\n};\n\n/**\n * Destroys/Deletes the databaase\n * @param dbName\n */\nDB.prototype.destroy = function destroy (dbName) {\n    console.info('database ' + dbName + ' deleted');\n    this.db.deleteDatabase(dbName);\n};\n\n/**\n * Creates connection in web worker space and if web worker fails\n * then creates normal database connection instance\n * @param resolve\n * @param reject\n */\nDB.prototype.createWorkerHandler = function createWorkerHandler (resolve, reject) {\n    var db = this;\n    try{\n        var worker = new window.Worker(db.pathToWebWorker);\n        var models = {};\n        var timestamp = Date.now();\n\n        worker.postMessage({\n            detail : JSON.stringify(db.settings),\n            action : 'initialize',\n            timestamp : timestamp\n        });\n            \n        worker.onmessage = function (e) {\n            if(e.data.action === 'initialize' && e.data.timestamp === timestamp) {\n                if (e.data.detail === true) {\n                    db.settings.migrations.forEach(function (schema) {\n                        Object.defineProperty(models, schema.name, {\n                            get: function get() {\n                                return new WorkerModelHandler(schema.name, worker, window);\n                            }\n                        });\n                    });\n\n                    db.isWebWorker = true;\n                    resolve(models);\n                } else {\n                    db.createNormalHandler(resolve, reject);\n                }\n            }\n        }\n\n    }catch (e) {\n        reject(e);\n    }\n\n};\n\n/**\n * Creates normal database instance and models\n * @param resolve\n * @param reject\n */\nDB.prototype.createNormalHandler = function createNormalHandler (resolve, reject) {\n    var db = this;\n\n    var request = this.db.open(this.settings.dbName, this.settings.dbVersion);\n\n    request.onupgradeneeded = function (e) {\n        var mig = new Migration(e.target.result, e.target.transaction, db.settings.migrations);\n        mig.run();\n    };\n\n    request.onerror = function (e) {\n        reject(e);\n    };\n\n    request.onsuccess = function (e) {\n        var models = {};\n\n        db.settings.migrations.forEach(function (schema) {\n            var primary = schema.primary || 'id';\n            Object.defineProperty(models, schema.name, {\n                get: function get() {\n                    return new Model(e.target.result, db.idbKey, schema.name, primary);\n                }\n            });\n        });\n\n        resolve(models);\n    };\n};\nvar Builder = function Builder () {\n    this.builder = [];\n    this.indexBuilder = {};\n    this.relations = [];\n    this.tables = [];\n};\n\nvar prototypeAccessors = { RELATIONS: {} };\nvar staticAccessors = { helpers: {},RELATIONS: {} };\n\n/**\n * Sets the index builder value as an 'and' reference\n *\n * @param indexName string\n * @param value mixed\n * @returns {Builder}\n */\nBuilder.prototype.whereIndex = function whereIndex (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'and'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value as an 'in' reference\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.whereIndexIn = function whereIndexIn (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'in'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with point inclusive and sets greater than check\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.indexGte = function indexGte (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'gte'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with point not inclusive and sets greater than check\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.indexGt = function indexGt (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'gt'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with point inclusive and sets less than check\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.indexLte = function indexLte (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'lte'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with point not inclusive and sets less than check\n *\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.indexLt = function indexLt (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'lt'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with points inclusive and sets range between them\n * @param indexName\n * @param lower\n * @param upper\n * @returns {Builder}\n */\nBuilder.prototype.indexBetween = function indexBetween (indexName, lower, upper) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : [lower, upper],\n        type : 'between'\n    };\n\n    return this;\n};\n\nBuilder.prototype.whereIn = function whereIn (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'in'\n    });\n\n    return this;\n};\n\nBuilder.prototype.where = function where (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'and'\n    });\n\n    return this;\n};\n\n\nBuilder.prototype.gte = function gte (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'gte'\n    });\n\n    return this;\n};\n\nBuilder.prototype.gt = function gt (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'gt'\n    });\n\n    return this;\n};\n\nBuilder.prototype.lte = function lte (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'lte'\n    });\n\n    return this;\n};\n\nBuilder.prototype.lt = function lt (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'lt'\n    });\n\n    return this;\n};\n\nBuilder.prototype.between = function between (attributeName, upper, lower) {\n    uppper = parseFloat(upper);\n    lower = parseFloat(lower);\n\n    if(isNaN(upper) || isNaN(lower)){\n        throw \"Between is only for numeric values\";\n    }\n\n    this.builder.push({\n        attribute : attributeName,\n        value : [upper, lower],\n        type : 'between'\n    });\n\n    return this;\n};\n\nBuilder.prototype.relation = function relation (modelName, type, localKey, foreignKey, func, primary) {\n    this.tables.push(modelName);\n\n    this.relations.push({\n        modelName : modelName,\n        func : func,\n        localKey : localKey,\n        foreignKey : foreignKey,\n        type : type,\n        primary : primary\n    });\n\n    return this;\n};\n\nstaticAccessors.helpers.get = function () {\n\n    return {\n\n        checkNestedAttribute: function checkNestedAttribute (attributeString, value, condition) {\n            return condition == Model.helpers.getNestedAttribute(attributeString, value)\n        },\n\n        getNestedAttribute: function getNestedAttribute(attributeString, value) {\n            var attributes = attributeString.split('.');\n            var i;\n            var content = value;\n\n            for(i = 0; i < attributes.length; i++) {\n                if(content[attributes[i]] === undefined){\n                    return undefined;\n                }\n\n                content = content[attributes[i]];\n            }\n\n            return content;\n        },\n\n        replaceNestedValues: function replaceNestedValues(attributes, value) {\n            for(var attribute in attributes) {\n                value[attribute] = attributes[attribute];\n            }\n\n            return value;\n        },\n    };\n\n};\n\nprototypeAccessors.RELATIONS.get = function () {\n    return Builder.RELATIONS;\n};\n\nstaticAccessors.RELATIONS.get = function () {\n    return {\n        hasOne : 'hasOne',\n        hasMany : 'hasMany'\n    }\n};\n\nObject.defineProperties( Builder.prototype, prototypeAccessors );\nObject.defineProperties( Builder, staticAccessors );\nvar Model = (function (Builder) {\n    function Model(db, idbKey, modelName, primary){\n        Builder.call(this);\n\n        this.name = modelName;\n        this.db = db;\n        this.primary = primary;\n        this.tables = [this.name];\n        this.idbKey = idbKey;\n        this.hasIdbKey = this.idbKey ? true : false;\n        this.transaction = null;\n        this.attributes = {};\n    }\n\n    if ( Builder ) Model.__proto__ = Builder;\n    Model.prototype = Object.create( Builder && Builder.prototype );\n    Model.prototype.constructor = Model;\n\n    var staticAccessors$1 = { READWRITE: {},READONLY: {} };\n\n    /**\n     * Finds the result on the primary key defined\n     * @param id\n     * @returns {Promise}\n     */\n    Model.prototype.find = function find (id) {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var request = obj.get(id);\n            \n            request.onsuccess = function (e) {\n                resolve(e.target.result);\n            };\n\n            request.onerror = function (e) {\n                reject(e);\n            };\n\n        });\n    };\n\n    /**\n     * Searches for first value in database and returns that\n     * @returns {Promise}\n     */\n    Model.prototype.first = function first () {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = null;\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        var relationsCompleted = 0;\n\n                        result = cursor.value;\n\n                        if(model.relations.length > 0 && (result !== null || result !== undefined)){\n\n\n                            model.relations.forEach(function (relation) {\n\n                                var relationRequest = model.getRelationships(relation, model.transaction, model.getMainResult(result, relation.localKey, false), false);\n\n                                relationRequest.then(function (relationResult) {\n\n                                    relationsCompleted++;\n\n                                    var defaultValue = model.getDefaultRelationValue(relation.type);\n                                    result[relation.modelName] = result[relation.modelName] || defaultValue;\n\n                                    switch (relation.type) {\n                                        case Model.RELATIONS.hasOne :\n                                            if (relationResult !== undefined) {\n                                                result[relation.modelName] = relationResult[relation.foreignKey] == result[relation.localKey] ? relationResult : result[relation.modelName];\n                                            }\n\n                                            break;\n                                        case Model.RELATIONS.hasMany :\n                                            if (relationResult.length > 0) {\n                                                result[relation.modelName] = relationResult.filter(function (relationResultItem) {\n                                                    return relationResultItem[relation.foreignKey] == result[relation.localKey];\n                                                });\n                                            }\n                                            break;\n                                    }\n\n                                    if (relationsCompleted == model.relations.length) {\n                                        resolve(result);\n                                    }\n\n                                }).catch(function (err) {\n                                    reject(err);\n                                });\n                            });\n                        }else{\n                            resolve(cursor.value);\n                            return false;\n                        }\n                    }else{\n                        cursor.continue();\n                    }\n\n                }else{\n                    resolve(result);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function searches throughout the database and returns a array of result\n     * @returns {Promise}\n     */\n    Model.prototype.get = function get () {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = [];\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        result.push(cursor.value);\n                    }\n                    cursor.continue();\n\n                }else{\n                    var mainResult, relationsCompleted = 0;\n\n                    if(model.relations.length > 0 && result.length > 0){\n\n\n                        model.relations.forEach(function (relation) {\n\n                            var relationRequest = model.getRelationships(relation, model.transaction, model.getMainResult(result, relation.localKey, true), true);\n\n                            relationRequest.then(function (relationResult) {\n\n                                relationsCompleted++;\n\n                                result = result.map(function (item) {\n\n                                    var defaultValue = model.getDefaultRelationValue(relation.type);\n                                    item[relation.modelName] = item[relation.modelName] || defaultValue;\n\n                                    switch (relation.type) {\n                                        case Model.RELATIONS.hasOne :\n                                            if(relationResult !== undefined) {\n                                                item[relation.modelName] = relationResult[relation.foreignKey] == item[relation.localKey] ? relationResult : item[relation.modelName];\n                                            }\n\n                                            break;\n                                        case Model.RELATIONS.hasMany :\n                                            if(relationResult.length > 0) {\n                                                item[relation.modelName] = relationResult.filter(function (relationResultItem) {\n                                                    return relationResultItem[relation.foreignKey] == item[relation.localKey];\n                                                });\n                                            }\n                                            break;\n                                    }\n\n                                    return item;\n                                });\n\n                                if(relationsCompleted == model.relations.length){\n                                    resolve(result);\n                                }\n\n                            }).catch(function (err) {\n                                reject(err);\n                            })\n                        });\n                    }else{\n                        resolve(result);\n                    }\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function creates a single record\n     * @param data\n     * @returns {Promise}\n     */\n    Model.prototype.create = function create (data) {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READWRITE);\n\n            var obj = transaction.objectStore(model.name);\n\n            data.createdAt = Date.now();\n            data.updatedAt = Date.now();\n\n            var request = obj.add(data);\n\n            request.onsuccess = function (e) {\n                data[model.primary] = e.target.result;\n                resolve(data);\n            };\n\n            request.onerror = function (e) {\n                reject(e);\n            };\n        });\n\n    };\n\n    /**\n     * Function creates list of records passed\n     * @param dataRecords\n     * @returns {Promise}\n     */\n    Model.prototype.createMultiple = function createMultiple (dataRecords) {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READWRITE);\n\n            var obj = transaction.objectStore(model.name);\n            var createdAt = Date.now();\n            var updatedAt = Date.now();\n            var result = [];\n\n            dataRecords.forEach(function (data) {\n                data.createdAt = createdAt;\n                data.updatedAt = updatedAt;\n\n                var request = obj.add(data);\n\n                request.onerror = function(e) {\n                    reject(e);\n                };\n\n                request.onsuccess = function(e) {\n                    data[model.primary] = e.target.result;\n\n                    result.push(data);\n\n                    if(result.length === dataRecords.length){\n                        resolve(result);\n                    }\n                };\n            })\n        });\n    };\n\n    /**\n     * Function updates the various records with matching values\n     * @param data\n     * @returns {Promise}\n     */\n    Model.prototype.update = function update (data) {\n\n        var model = this;\n        var updatedAt = Date.now();\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READWRITE);\n            var obj = transaction.objectStore(model.name);\n            var request, totalRecordsBeingUpdated = 0, totalRecordsUpdated = 0;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        totalRecordsBeingUpdated++;\n\n                        var id = cursor.value[model.primary];\n                        var createdAt = cursor.value.createdAt;\n\n                        var result = Model.helpers.replaceNestedValues(data, cursor.value);\n                        result[model.primary] = id;\n                        result.createdAt = createdAt;\n                        result.updatedAt = updatedAt;\n\n                        var updateRequest = cursor.update(result);\n\n                        updateRequest.onsuccess = function() {\n                            totalRecordsUpdated++;\n\n                            if(totalRecordsUpdated === totalRecordsBeingUpdated){\n                                resolve(true);\n                            }\n                        };\n\n                        updateRequest.onerror = function(err) {\n                            transaction.abort();\n                            reject(err);\n                        };\n\n                    }\n                    cursor.continue();\n\n                }else{\n                    resolve();\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function updates the record at the given id\n     * @param id\n     * @param data\n     * @returns {Promise}\n     */\n    Model.prototype.save = function save (id, data) {\n        var model = this;\n        var updatedAt = Date.now();\n\n        return new Promise(function (resolve, reject) {\n\n            model.find(id).then(function (result) {\n\n                if(!result){\n                    reject('No record found');\n                }\n\n                var transaction = model.getTransaction(model.tables, Model.READWRITE, true);\n                var obj = transaction.objectStore(model.name);\n\n                var id = result[model.primary];\n                var createdAt = result.createdAt;\n\n                result = Model.helpers.replaceNestedValues(data, result);\n                result[model.primary] = id;\n                result.createdAt = createdAt;\n                result.updatedAt = updatedAt;\n\n                var request = obj.put(result);\n\n                request.onsuccess = function () {\n                    resolve(true);\n                };\n\n                request.onerror = function(e) {\n                    reject(e);\n                }\n            }).catch(function (err) {\n                reject(err);\n            });\n\n        });\n    };\n\n    /**\n     * Function deletes the entries at the given point\n     * @param id\n     * @returns {Promise}\n     */\n    Model.prototype.destroyId = function destroyId (id) {\n        var model = this;\n\n\n        return new Promise(function (resolve, reject) {\n            model.find(id).then(function (result) {\n\n                if(!result){\n                    reject('result at id does not exists');\n                }\n\n                var transaction = model.getTransaction(model.tables, Model.READWRITE, true);\n                var obj = transaction.objectStore(model.name);\n                var request = obj.delete(id);\n\n                request.onsuccess = function (e) {\n                    resolve(e.target.result);\n                };\n\n                request.onerror = function (e) {\n                    reject(e);\n                };\n            }).catch(function (err) {\n                reject(err);\n            });\n\n\n        });\n    };\n\n    /**\n     * Function deletes the entries\n     * @returns {Promise}\n     */\n    Model.prototype.destroy = function destroy () {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READWRITE);\n            var obj = transaction.objectStore(model.name);\n            var request, totalRecordsBeingDeleted = 0, totalRecordsDeleted = 0;\n\n            if (model.indexBuilder.type) {\n                request = model.getIndexResult(obj);\n            } else {\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if (cursor) {\n                    if (model.checkBuilderValue(cursor.value)) {\n                        totalRecordsBeingDeleted++;\n\n                        var deleteRequest = cursor.delete();\n\n                        deleteRequest.onsuccess = function () {\n                            totalRecordsDeleted++;\n\n                            if (totalRecordsDeleted === totalRecordsBeingDeleted) {\n                                resolve(true);\n                            }\n                        };\n\n                        deleteRequest.onerror = function (err) {\n                            transaction.abort();\n                            reject(err);\n                        };\n\n                    }\n                    cursor.continue();\n\n                } else {\n                    resolve();\n                }\n            };\n\n            request.onerror = function (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function counts the number of records\n     * @returns {Promise}\n     */\n    Model.prototype.count = function count () {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = 0;\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        result++;\n                    }\n\n                    cursor.continue();\n\n                }else{\n                    resolve(result);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function averages the numeric value at the given point\n     * @param attribute\n     * @returns {Promise}\n     */\n    Model.prototype.average = function average (attribute) {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = 0, totalRecords = 0;\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        totalRecords++;\n                        var tempResult = Model.helpers.getNestedAttribute(attribute, cursor.value);\n                        tempResult = parseFloat(tempResult);\n                        tempResult = isNaN(tempResult) ? 0 : tempResult;\n                        result += tempResult;\n                    }\n\n                    cursor.continue();\n\n                }else{\n                    resolve(result/totalRecords);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Reduce function is called with each passing iterator value and reduced value is returned\n     * @param func\n     * @param defaultCarry\n     * @returns {Promise}\n     */\n    Model.prototype.reduce = function reduce (func, defaultCarry) {\n        var model = this;\n\n        if(typeof func !== 'function'){\n            throw \"Parameter should be a function type\";\n        }\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = defaultCarry;\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        result = func(cursor.value, result);\n                    }\n\n                    cursor.continue();\n\n                }else{\n                    resolve(result);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Sets the index search criteria\n     * @param objectStore\n     * @returns {*}\n     */\n    Model.prototype.getIndexResult = function getIndexResult (objectStore) {\n        var builder = this;\n        var range;\n        var index;\n\n\n        if(!builder.indexBuilder.type) {\n            return objectStore.openCursor();\n        }\n\n        if(builder.indexBuilder.index !== builder.primary){\n            index = objectStore.index(builder.indexBuilder.index);\n        }else{\n            index = objectStore;\n        }\n\n        switch (builder.indexBuilder.type) {\n            case 'and' :\n                range = builder.idbKey.only(builder.indexBuilder.value);\n                break;\n\n            case 'in' :\n                builder.whereIn(builder.indexBuilder.index, builder.indexBuilder.value);\n                var values = builder.indexBuilder.value.sort();\n                range = builder.idbKey.bound(values[0], values[values.length - 1], false, false);\n                break;\n\n            case 'gte' :\n                range = builder.idbKey.lowerBound(builder.indexBuilder.value, false);\n                break;\n\n            case 'gt' :\n                range = builder.idbKey.lowerBound(builder.indexBuilder.value, true);\n                break;\n\n            case 'lte' :\n                range = builder.idbKey.upperBound(builder.indexBuilder.value, false);\n                break;\n\n            case 'lt' :\n                range = builder.idbKey.lowerBound(builder.indexBuilder.value, true);\n                break;\n\n            case 'between' :\n                range = builder.idbKey.bound(builder.indexBuilder.value[0], builder.indexBuilder.value[1], false, false);\n                break;\n            default :\n                throw 'Invalid builder type found';\n        }\n\n        return index.openCursor(range);\n    };\n\n    /**\n     * Checks common search criteria other than the index values\n     * @param value\n     * @returns {boolean}\n     */\n    Model.prototype.checkBuilderValue = function checkBuilderValue (value) {\n        var builder = this;\n        var result = true;\n        var i,j;\n        for (i = 0; i < builder.builder.length; i++){\n\n            var condition = builder.builder[i];\n            switch(condition.type){\n\n                case 'and' : //case for one to one search\n                    if(!Model.helpers.checkNestedAttribute(condition.attribute, value, condition.value)){\n                        return false;\n                    }\n                    break;\n\n                case 'in' : //case for list search\n                    var tempCheck = false;\n                    for(j = 0; j < condition.value.length; j++) {\n                        result = Model.helpers.checkNestedAttribute(condition.attribute, value, condition.value[j]);\n                        if(result !== undefined && result !== false) {\n                            tempCheck = true;\n                        }\n                    }\n\n                    if(!tempCheck){\n                        return false;\n                    }\n\n                    result = true;\n\n                    break;\n\n                case 'gte' : //case for checking the value is greater than or is equal to the same\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result < condition.value){\n                        return false;\n                    }\n\n                    result = true;\n                    break;\n\n                case 'gt' : //case for checking the value is greater than the same\n\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result <= condition.value){\n                        return false;\n                    }\n\n                    result = true;\n                    break;\n\n                case 'lte' : //case for checking the value is less than or is equal to the same\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result > condition.value){\n                        return false;\n                    }\n                    result = true;\n                    break;\n\n                case 'lt' : //case for checking the value is less than the same\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result >= condition.value){\n                        return false;\n                    }\n                    result = true;\n                    break;\n\n                case 'between' : //case for checking the value is between the given range(ONLY WORKS FOR NUMERIC)\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(condition.value[0] >= result && condition.value[1] <= result){\n                        return false\n                    }\n                    result = true;\n                    break;\n\n                default:\n                    result = true;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Creates a transaction\n     * @param tables\n     * @param mode\n     */\n    Model.prototype.createTransaction = function createTransaction (tables, mode) {\n        this.transaction = this.db.transaction(tables, mode)\n    };\n\n    /**\n     * Sets IDBTransaction obejct to current model scope\n     * @param transaction\n     */\n    Model.prototype.setTransaction = function setTransaction (transaction) {\n        this.transaction = transaction\n    };\n\n    /**\n     * Returns the IDBTransaction object set in current scope\n     * @param {Array} tables\n     * @param {String} mode\n     * @param {boolean} overwrite\n     * @returns {*|null}\n     */\n    Model.prototype.getTransaction = function getTransaction (tables, mode, overwrite) {\n        overwrite = overwrite === undefined ? false : overwrite;\n\n        if(!this.transaction || overwrite === true) {\n            this.createTransaction(tables, mode);\n        }\n\n        return this.transaction;\n    };\n\n    /**\n     * Returns the array or direct key value against the input give for the key specified\n     * @param result\n     * @param key\n     * @param isArray\n     * @returns {*}\n     */\n    Model.prototype.getMainResult = function getMainResult (result, key, isArray) {\n        if(isArray){\n            return result.map(function (item) {\n                return item[key];\n            });\n        }else{\n            return result[key];\n        }\n    };\n\n    /**\n     * Searches for relationships assigned with builder and fetches them\n     * @param relation\n     * @param transaction\n     * @param mainResult\n     * @param isArray\n     * @returns {Promise}\n     */\n    Model.prototype.getRelationships = function getRelationships (relation, transaction, mainResult, isArray) {\n\n        isArray = isArray || false;\n\n        var model = this;\n        var primary = relation.primary || 'id';\n\n        /**\n         * @var Model relationModel\n         */\n        var relationModel = new Model(model.db, model.idbKey, relation.modelName, relation.primary);\n\n        //setting the relation transaction same as parent transaction\n        relationModel.setTransaction(transaction);\n\n        //if a secondry builder function was defined\n        if(relation.func){\n            var tempBuilder = new Builder();\n\n            tempBuilder = relation.func(tempBuilder);\n\n            relationModel.tables = tempBuilder.tables;\n            relationModel.tables.push(relationModel.name);\n            relationModel.relations = tempBuilder.relations;\n            relationModel.builder = tempBuilder.builder;\n        }\n\n        //checking type of parent result\n        if(isArray){\n            relationModel.whereIndexIn(relation.foreignKey, mainResult);\n        }else{\n            relationModel.whereIndex(relation.foreignKey, mainResult);\n        }\n\n        return new Promise(function (relationResolve, relationReject) {\n\n            var result;\n\n            //if relation type mentioned\n            switch (relation.type) {\n                case Model.RELATIONS.hasOne :\n                    result = relationModel.first();\n                    break;\n                case Model.RELATIONS.hasMany :\n                    result = relationModel.get();\n                    break;\n                default :\n                    throw \"Invalid relation type provided\";\n            }\n\n            result.then(function (r) {\n                relationResolve(r);\n            }).catch(function (err) {\n                relationReject(err);\n            });\n\n        });\n    };\n\n    /**\n     * Gets the default value of result. Null for hasOne and array for hasMany\n     * @param type\n     * @returns {*}\n     */\n    Model.prototype.getDefaultRelationValue = function getDefaultRelationValue (type) {\n    switch (type) {\n        case Model.RELATIONS.hasOne :\n            return null;\n        case Model.RELATIONS.hasMany :\n            return [];\n        default :\n            return null;\n    }\n};\n\n\n    /**\n     * Readwrite parameter of indexedDB\n     * @return {string}\n     */\n    staticAccessors$1.READWRITE.get = function () {\n        return \"readwrite\";\n    };\n\n    /**\n     * Readonly parameter of indexedDB\n     * @return {string}\n     */\n    staticAccessors$1.READONLY.get = function () {\n        return \"readonly\";\n    };\n\n    Object.defineProperties( Model, staticAccessors$1 );\n\n    return Model;\n}(Builder));\n\nvar Migration = function Migration(db, transaction, migrations) {\n    /**\n     * @var IDBDatabase db\n     */\n    this.db = db;\n    this.migrations = migrations;\n    this.objectStores = [];\n\n    /**\n     * @var IDBTransaction transaction\n     */\n    this.transaction = transaction;\n};\n\nMigration.prototype.createStore = function createStore (schema) {\n    var mig = this;\n    var primary = schema.primary || 'id';\n\n    var objectStore = mig.db.createObjectStore(schema.name, {keyPath: primary, autoIncrement: true});\n    mig.objectStores.push(objectStore);\n\n    if (schema.columns) {\n        schema.columns.forEach(function (column) { return mig.makeIndex(column, objectStore); });\n    }\n\n\n};\n\nMigration.prototype.run = function run () {\n    var mig = this;\n\n    mig.migrations.forEach(function (schema) {\n        if(mig.db.objectStoreNames.contains(schema.name)){\n\n            if(schema.drop){\n                mig.db.deleteObjectStore(schema.name);\n            }else{\n                mig.updateStore(schema);\n            }\n\n\n        }else{\n            mig.createStore(schema);\n        }\n    });\n};\n\nMigration.prototype.makeIndex = function makeIndex (column, objectStore) {\n    column.attributes = column.attributes || {};\n    column.index = column.index || column.name;\n    objectStore.createIndex(column.name, column.index, column.attributes);\n};\n\nMigration.prototype.updateStore = function updateStore (schema) {\n    var mig = this;\n\n    var objectStore = mig.transaction.objectStore(schema.name);\n\n    if (schema.columns) {\n\n        schema.columns.forEach(function (column) {\n            if(!objectStore.indexNames.contains(column.name)){\n                mig.makeIndex(column, objectStore)\n            }\n        });\n    }\n\n    if(schema.dropColumns) {\n        schema.dropColumns.forEach(function (column) {\n            if(objectStore.indexNames.contains(column)){\n                mig.dropIndex(column, objectStore)\n            }\n        });\n    }\n};\n\nMigration.prototype.dropIndex = function dropIndex (columnName, objectStore) {\n    debugger;\n    objectStore.deleteIndex(columnName);\n};\n\n\n\nvar db, models;\nvar errorNamespace = '-error';\n\nself.addEventListener('message', function (e) {\n    \"use strict\";\n    JSON.parse(e.data.detail);\n    var data = JSON.parse(e.data.detail, function (key, value) {\n        if(typeof value != 'string'){\n            return value;\n        }\n        return ( value.indexOf('function') >= 0 || value.indexOf('=>') >= 0) ? eval('('+value+')') : value;\n    });\n    self.emit(data, e.data.timestamp, e.data.action, e.data.model);\n});\n\nself.addEventListener('idb:worker:initialize', function (e) {\n    \"use strict\";\n\n    var idb = self.indexedDB || self.mozIndexedDB || self.webkitIndexedDB || self.msIndexedDB;\n    var idbKey = self.IDBKeyRange || self.webkitIDBKeyRange || self.msIDBKeyRange;\n\n    db = new DB(idb, idbKey, e.detail.detail, false);\n\n    db.connect()\n        .then(function (m) {\n            models = m;\n            self.send(true, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (e) { return self.send(false, e.detail.timestamp, e.detail.action); });\n\n});\n\nself.emit = function (data, timestamp, action, model) {\n    var ev = new self.CustomEvent('idb:worker:' + action, {\n        detail: {\n            detail: data,\n            timestamp: timestamp,\n            action: action,\n            model: model\n        }\n    });\n\n    self.dispatchEvent(ev);\n};\n\nself.send = function (data, timestamp, action) {\n    \"use strict\";\n\n    var ev = {\n        detail: data,\n        action: action,\n        timestamp: timestamp,\n    };\n\n    self.postMessage(ev);\n};\n\n\nself.addEventListener('idb:worker:create', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.create(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:find', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n    m.builder = e.detail.detail.builder;\n    m.indexBuilder = e.detail.detail.indexBuilder;\n    m.tables = e.detail.detail.tables;\n    m.relations = e.detail.detail.relations;\n\n    m.find(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:createMultiple', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n    m.createMultiple(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:get', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n    m.builder = e.detail.detail.builder;\n    m.indexBuilder = e.detail.detail.indexBuilder;\n    m.tables = e.detail.detail.tables;\n    m.relations = e.detail.detail.relations;\n\n    m.get(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:first', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n    m.builder = e.detail.detail.builder;\n    m.indexBuilder = e.detail.detail.indexBuilder;\n    m.tables = e.detail.detail.tables;\n    m.relations = e.detail.detail.relations;\n\n    m.first(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (err) {\n            self.send(err, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:update', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.update(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:save', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.save(e.detail.detail.id, e.detail.detail.data)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:count', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.count()\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:average', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.average(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\n\nself.addEventListener('idb:worker:reduce', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.reduce(e.detail.detail.func, e.detail.detail.defaultCarry)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:destroyId', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.destroyId(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:destroy', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.destroy()\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n//# sourceMappingURL=worker.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9idWlsZC93b3JrZXIuanM/YmUwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBEQiB7XG5cbiAgICBjb25zdHJ1Y3RvcihpZGIsIGlkYktleSwgc2V0dGluZ3MsIHVzZVdlYldvcmtlciwgcGF0aFRvV2ViV29ya2VyKSB7XG4gICAgICAgIHRoaXMuZGIgPSBpZGI7XG4gICAgICAgIHRoaXMuaWRiS2V5ID0gaWRiS2V5O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMudXNlV2ViV29ya2VyID0gdXNlV2ViV29ya2VyIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmlzV2ViV29ya2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF0aFRvV2ViV29ya2VyID0gcGF0aFRvV2ViV29ya2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGRhdGFiYXNlIGNvbm5lY3Rpb24gd2l0aCBpbmRleGVkREJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGxldCBkYiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIGlmKGRiLnVzZVdlYldvcmtlcil7XG4gICAgICAgICAgICAgICAgZGIuY3JlYXRlV29ya2VySGFuZGxlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZGIuY3JlYXRlTm9ybWFsSGFuZGxlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cy9EZWxldGVzIHRoZSBkYXRhYmFhc2VcbiAgICAgKiBAcGFyYW0gZGJOYW1lXG4gICAgICovXG4gICAgZGVzdHJveShkYk5hbWUpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdkYXRhYmFzZSAnICsgZGJOYW1lICsgJyBkZWxldGVkJyk7XG4gICAgICAgIHRoaXMuZGIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNvbm5lY3Rpb24gaW4gd2ViIHdvcmtlciBzcGFjZSBhbmQgaWYgd2ViIHdvcmtlciBmYWlsc1xuICAgICAqIHRoZW4gY3JlYXRlcyBub3JtYWwgZGF0YWJhc2UgY29ubmVjdGlvbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSByZXNvbHZlXG4gICAgICogQHBhcmFtIHJlamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZVdvcmtlckhhbmRsZXIgKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsZXQgZGIgPSB0aGlzO1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBsZXQgd29ya2VyID0gbmV3IHdpbmRvdy5Xb3JrZXIoZGIucGF0aFRvV2ViV29ya2VyKTtcbiAgICAgICAgICAgIGxldCBtb2RlbHMgPSB7fTtcbiAgICAgICAgICAgIGxldCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGRldGFpbCA6IEpTT04uc3RyaW5naWZ5KGRiLnNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICBhY3Rpb24gOiAnaW5pdGlhbGl6ZScsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wIDogdGltZXN0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYoZS5kYXRhLmFjdGlvbiA9PT0gJ2luaXRpYWxpemUnICYmIGUuZGF0YS50aW1lc3RhbXAgPT09IHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLmRldGFpbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuc2V0dGluZ3MubWlncmF0aW9ucy5mb3JFYWNoKChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kZWxzLCBzY2hlbWEubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmtlck1vZGVsSGFuZGxlcihzY2hlbWEubmFtZSwgd29ya2VyLCB3aW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGIuaXNXZWJXb3JrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtb2RlbHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlTm9ybWFsSGFuZGxlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1jYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5vcm1hbCBkYXRhYmFzZSBpbnN0YW5jZSBhbmQgbW9kZWxzXG4gICAgICogQHBhcmFtIHJlc29sdmVcbiAgICAgKiBAcGFyYW0gcmVqZWN0XG4gICAgICovXG4gICAgY3JlYXRlTm9ybWFsSGFuZGxlciAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBkYiA9IHRoaXM7XG5cbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmRiLm9wZW4odGhpcy5zZXR0aW5ncy5kYk5hbWUsIHRoaXMuc2V0dGluZ3MuZGJWZXJzaW9uKTtcblxuICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBsZXQgbWlnID0gbmV3IE1pZ3JhdGlvbihlLnRhcmdldC5yZXN1bHQsIGUudGFyZ2V0LnRyYW5zYWN0aW9uLCBkYi5zZXR0aW5ncy5taWdyYXRpb25zKTtcbiAgICAgICAgICAgIG1pZy5ydW4oKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGxldCBtb2RlbHMgPSB7fTtcblxuICAgICAgICAgICAgZGIuc2V0dGluZ3MubWlncmF0aW9ucy5mb3JFYWNoKChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJpbWFyeSA9IHNjaGVtYS5wcmltYXJ5IHx8ICdpZCc7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZGVscywgc2NoZW1hLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2RlbChlLnRhcmdldC5yZXN1bHQsIGRiLmlkYktleSwgc2NoZW1hLm5hbWUsIHByaW1hcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzb2x2ZShtb2RlbHMpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIEJ1aWxkZXIge1xuXG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleEJ1aWxkZXIgPSB7fTtcbiAgICAgICAgdGhpcy5yZWxhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50YWJsZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmRleCBidWlsZGVyIHZhbHVlIGFzIGFuICdhbmQnIHJlZmVyZW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4TmFtZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFsdWUgbWl4ZWRcbiAgICAgKiBAcmV0dXJucyB7QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aGVyZUluZGV4KGluZGV4TmFtZSwgdmFsdWUpIHtcblxuICAgICAgICB0aGlzLmluZGV4QnVpbGRlciA9IHtcbiAgICAgICAgICAgIGluZGV4IDogaW5kZXhOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnYW5kJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluZGV4IGJ1aWxkZXIgdmFsdWUgYXMgYW4gJ2luJyByZWZlcmVuY2VcbiAgICAgKiBAcGFyYW0gaW5kZXhOYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge0J1aWxkZXJ9XG4gICAgICovXG4gICAgd2hlcmVJbmRleEluKGluZGV4TmFtZSwgdmFsdWUpIHtcblxuICAgICAgICB0aGlzLmluZGV4QnVpbGRlciA9IHtcbiAgICAgICAgICAgIGluZGV4IDogaW5kZXhOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnaW4nXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5kZXggYnVpbGRlciB2YWx1ZSB3aXRoIHBvaW50IGluY2x1c2l2ZSBhbmQgc2V0cyBncmVhdGVyIHRoYW4gY2hlY2tcbiAgICAgKiBAcGFyYW0gaW5kZXhOYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge0J1aWxkZXJ9XG4gICAgICovXG4gICAgaW5kZXhHdGUoaW5kZXhOYW1lLCB2YWx1ZSkge1xuXG4gICAgICAgIHRoaXMuaW5kZXhCdWlsZGVyID0ge1xuICAgICAgICAgICAgaW5kZXggOiBpbmRleE5hbWUsXG4gICAgICAgICAgICB2YWx1ZSA6IHZhbHVlLFxuICAgICAgICAgICAgdHlwZSA6ICdndGUnXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5kZXggYnVpbGRlciB2YWx1ZSB3aXRoIHBvaW50IG5vdCBpbmNsdXNpdmUgYW5kIHNldHMgZ3JlYXRlciB0aGFuIGNoZWNrXG4gICAgICogQHBhcmFtIGluZGV4TmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCdWlsZGVyfVxuICAgICAqL1xuICAgIGluZGV4R3QoaW5kZXhOYW1lLCB2YWx1ZSkge1xuXG4gICAgICAgIHRoaXMuaW5kZXhCdWlsZGVyID0ge1xuICAgICAgICAgICAgaW5kZXggOiBpbmRleE5hbWUsXG4gICAgICAgICAgICB2YWx1ZSA6IHZhbHVlLFxuICAgICAgICAgICAgdHlwZSA6ICdndCdcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmRleCBidWlsZGVyIHZhbHVlIHdpdGggcG9pbnQgaW5jbHVzaXZlIGFuZCBzZXRzIGxlc3MgdGhhbiBjaGVja1xuICAgICAqIEBwYXJhbSBpbmRleE5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QnVpbGRlcn1cbiAgICAgKi9cbiAgICBpbmRleEx0ZShpbmRleE5hbWUsIHZhbHVlKSB7XG5cbiAgICAgICAgdGhpcy5pbmRleEJ1aWxkZXIgPSB7XG4gICAgICAgICAgICBpbmRleCA6IGluZGV4TmFtZSxcbiAgICAgICAgICAgIHZhbHVlIDogdmFsdWUsXG4gICAgICAgICAgICB0eXBlIDogJ2x0ZSdcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmRleCBidWlsZGVyIHZhbHVlIHdpdGggcG9pbnQgbm90IGluY2x1c2l2ZSBhbmQgc2V0cyBsZXNzIHRoYW4gY2hlY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleE5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QnVpbGRlcn1cbiAgICAgKi9cbiAgICBpbmRleEx0KGluZGV4TmFtZSwgdmFsdWUpIHtcblxuICAgICAgICB0aGlzLmluZGV4QnVpbGRlciA9IHtcbiAgICAgICAgICAgIGluZGV4IDogaW5kZXhOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnbHQnXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5kZXggYnVpbGRlciB2YWx1ZSB3aXRoIHBvaW50cyBpbmNsdXNpdmUgYW5kIHNldHMgcmFuZ2UgYmV0d2VlbiB0aGVtXG4gICAgICogQHBhcmFtIGluZGV4TmFtZVxuICAgICAqIEBwYXJhbSBsb3dlclxuICAgICAqIEBwYXJhbSB1cHBlclxuICAgICAqIEByZXR1cm5zIHtCdWlsZGVyfVxuICAgICAqL1xuICAgIGluZGV4QmV0d2VlbihpbmRleE5hbWUsIGxvd2VyLCB1cHBlcikge1xuXG4gICAgICAgIHRoaXMuaW5kZXhCdWlsZGVyID0ge1xuICAgICAgICAgICAgaW5kZXggOiBpbmRleE5hbWUsXG4gICAgICAgICAgICB2YWx1ZSA6IFtsb3dlciwgdXBwZXJdLFxuICAgICAgICAgICAgdHlwZSA6ICdiZXR3ZWVuJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHdoZXJlSW4oYXR0cmlidXRlTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWlsZGVyLnB1c2goe1xuICAgICAgICAgICAgYXR0cmlidXRlIDogYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgIHZhbHVlIDogdmFsdWUsXG4gICAgICAgICAgICB0eXBlIDogJ2luJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB3aGVyZShhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnYW5kJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGd0ZShhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnZ3RlJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBndChhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnZ3QnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGx0ZShhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnbHRlJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsdChhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnbHQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGJldHdlZW4oYXR0cmlidXRlTmFtZSwgdXBwZXIsIGxvd2VyKSB7XG4gICAgICAgIHVwcHBlciA9IHBhcnNlRmxvYXQodXBwZXIpO1xuICAgICAgICBsb3dlciA9IHBhcnNlRmxvYXQobG93ZXIpO1xuXG4gICAgICAgIGlmKGlzTmFOKHVwcGVyKSB8fCBpc05hTihsb3dlcikpe1xuICAgICAgICAgICAgdGhyb3cgXCJCZXR3ZWVuIGlzIG9ubHkgZm9yIG51bWVyaWMgdmFsdWVzXCI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiBbdXBwZXIsIGxvd2VyXSxcbiAgICAgICAgICAgIHR5cGUgOiAnYmV0d2VlbidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVsYXRpb24obW9kZWxOYW1lLCB0eXBlLCBsb2NhbEtleSwgZm9yZWlnbktleSwgZnVuYywgcHJpbWFyeSkge1xuICAgICAgICB0aGlzLnRhYmxlcy5wdXNoKG1vZGVsTmFtZSk7XG5cbiAgICAgICAgdGhpcy5yZWxhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBtb2RlbE5hbWUgOiBtb2RlbE5hbWUsXG4gICAgICAgICAgICBmdW5jIDogZnVuYyxcbiAgICAgICAgICAgIGxvY2FsS2V5IDogbG9jYWxLZXksXG4gICAgICAgICAgICBmb3JlaWduS2V5IDogZm9yZWlnbktleSxcbiAgICAgICAgICAgIHR5cGUgOiB0eXBlLFxuICAgICAgICAgICAgcHJpbWFyeSA6IHByaW1hcnlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBoZWxwZXJzKCkge1xuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIGNoZWNrTmVzdGVkQXR0cmlidXRlIChhdHRyaWJ1dGVTdHJpbmcsIHZhbHVlLCBjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uID09IE1vZGVsLmhlbHBlcnMuZ2V0TmVzdGVkQXR0cmlidXRlKGF0dHJpYnV0ZVN0cmluZywgdmFsdWUpXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXROZXN0ZWRBdHRyaWJ1dGUoYXR0cmlidXRlU3RyaW5nLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCBhdHRyaWJ1dGVzID0gYXR0cmlidXRlU3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY29udGVudFthdHRyaWJ1dGVzW2ldXSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudFthdHRyaWJ1dGVzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlcGxhY2VOZXN0ZWRWYWx1ZXMoYXR0cmlidXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGF0dHJpYnV0ZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2F0dHJpYnV0ZV0gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIGdldCBSRUxBVElPTlMgKCkge1xuICAgICAgICByZXR1cm4gQnVpbGRlci5SRUxBVElPTlM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBSRUxBVElPTlMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYXNPbmUgOiAnaGFzT25lJyxcbiAgICAgICAgICAgIGhhc01hbnkgOiAnaGFzTWFueSdcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIE1vZGVsIGV4dGVuZHMgQnVpbGRlcntcblxuICAgIGNvbnN0cnVjdG9yKGRiLCBpZGJLZXksIG1vZGVsTmFtZSwgcHJpbWFyeSl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gbW9kZWxOYW1lO1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMucHJpbWFyeSA9IHByaW1hcnk7XG4gICAgICAgIHRoaXMudGFibGVzID0gW3RoaXMubmFtZV07XG4gICAgICAgIHRoaXMuaWRiS2V5ID0gaWRiS2V5O1xuICAgICAgICB0aGlzLmhhc0lkYktleSA9IHRoaXMuaWRiS2V5ID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHJlc3VsdCBvbiB0aGUgcHJpbWFyeSBrZXkgZGVmaW5lZFxuICAgICAqIEBwYXJhbSBpZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZpbmQoaWQpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbW9kZWwuZ2V0VHJhbnNhY3Rpb24obW9kZWwudGFibGVzLCBNb2RlbC5SRUFET05MWSk7XG4gICAgICAgICAgICBsZXQgb2JqID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUobW9kZWwubmFtZSk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IG9iai5nZXQoaWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBmaXJzdCB2YWx1ZSBpbiBkYXRhYmFzZSBhbmQgcmV0dXJucyB0aGF0XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgZmlyc3QoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRE9OTFkpO1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdDtcblxuICAgICAgICAgICAgaWYobW9kZWwuaW5kZXhCdWlsZGVyLnR5cGUpe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBtb2RlbC5nZXRJbmRleFJlc3VsdChvYmopO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG9iai5vcGVuQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYoY3Vyc29yKXtcbiAgICAgICAgICAgICAgICAgICAgaWYobW9kZWwuY2hlY2tCdWlsZGVyVmFsdWUoY3Vyc29yLnZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVsYXRpb25zQ29tcGxldGVkID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY3Vyc29yLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtb2RlbC5yZWxhdGlvbnMubGVuZ3RoID4gMCAmJiAocmVzdWx0ICE9PSBudWxsIHx8IHJlc3VsdCAhPT0gdW5kZWZpbmVkKSl7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnJlbGF0aW9ucy5mb3JFYWNoKChyZWxhdGlvbikgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWxhdGlvblJlcXVlc3QgPSBtb2RlbC5nZXRSZWxhdGlvbnNoaXBzKHJlbGF0aW9uLCBtb2RlbC50cmFuc2FjdGlvbiwgbW9kZWwuZ2V0TWFpblJlc3VsdChyZXN1bHQsIHJlbGF0aW9uLmxvY2FsS2V5LCBmYWxzZSksIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvblJlcXVlc3QudGhlbigocmVsYXRpb25SZXN1bHQpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zQ29tcGxldGVkKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0VmFsdWUgPSBtb2RlbC5nZXREZWZhdWx0UmVsYXRpb25WYWx1ZShyZWxhdGlvbi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZWxhdGlvbi5tb2RlbE5hbWVdID0gcmVzdWx0W3JlbGF0aW9uLm1vZGVsTmFtZV0gfHwgZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlbGF0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVsLlJFTEFUSU9OUy5oYXNPbmUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpb25SZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3JlbGF0aW9uLm1vZGVsTmFtZV0gPSByZWxhdGlvblJlc3VsdFtyZWxhdGlvbi5mb3JlaWduS2V5XSA9PSByZXN1bHRbcmVsYXRpb24ubG9jYWxLZXldID8gcmVsYXRpb25SZXN1bHQgOiByZXN1bHRbcmVsYXRpb24ubW9kZWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZWwuUkVMQVRJT05TLmhhc01hbnkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpb25SZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3JlbGF0aW9uLm1vZGVsTmFtZV0gPSByZWxhdGlvblJlc3VsdC5maWx0ZXIoKHJlbGF0aW9uUmVzdWx0SXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWxhdGlvblJlc3VsdEl0ZW1bcmVsYXRpb24uZm9yZWlnbktleV0gPT0gcmVzdWx0W3JlbGF0aW9uLmxvY2FsS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpb25zQ29tcGxldGVkID09IG1vZGVsLnJlbGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBzZWFyY2hlcyB0aHJvdWdob3V0IHRoZSBkYXRhYmFzZSBhbmQgcmV0dXJucyBhIGFycmF5IG9mIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbW9kZWwuZ2V0VHJhbnNhY3Rpb24obW9kZWwudGFibGVzLCBNb2RlbC5SRUFET05MWSk7XG4gICAgICAgICAgICBsZXQgb2JqID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUobW9kZWwubmFtZSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBsZXQgcmVxdWVzdDtcblxuICAgICAgICAgICAgaWYobW9kZWwuaW5kZXhCdWlsZGVyLnR5cGUpe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBtb2RlbC5nZXRJbmRleFJlc3VsdChvYmopO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG9iai5vcGVuQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYoY3Vyc29yKXtcbiAgICAgICAgICAgICAgICAgICAgaWYobW9kZWwuY2hlY2tCdWlsZGVyVmFsdWUoY3Vyc29yLnZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYWluUmVzdWx0LCByZWxhdGlvbnNDb21wbGV0ZWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKG1vZGVsLnJlbGF0aW9ucy5sZW5ndGggPiAwICYmIHJlc3VsdC5sZW5ndGggPiAwKXtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5yZWxhdGlvbnMuZm9yRWFjaCgocmVsYXRpb24pID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWxhdGlvblJlcXVlc3QgPSBtb2RlbC5nZXRSZWxhdGlvbnNoaXBzKHJlbGF0aW9uLCBtb2RlbC50cmFuc2FjdGlvbiwgbW9kZWwuZ2V0TWFpblJlc3VsdChyZXN1bHQsIHJlbGF0aW9uLmxvY2FsS2V5LCB0cnVlKSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvblJlcXVlc3QudGhlbigocmVsYXRpb25SZXN1bHQpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNDb21wbGV0ZWQrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGl0ZW0gPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gbW9kZWwuZ2V0RGVmYXVsdFJlbGF0aW9uVmFsdWUocmVsYXRpb24udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtW3JlbGF0aW9uLm1vZGVsTmFtZV0gPSBpdGVtW3JlbGF0aW9uLm1vZGVsTmFtZV0gfHwgZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlbGF0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVsLlJFTEFUSU9OUy5oYXNPbmUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZWxhdGlvblJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtW3JlbGF0aW9uLm1vZGVsTmFtZV0gPSByZWxhdGlvblJlc3VsdFtyZWxhdGlvbi5mb3JlaWduS2V5XSA9PSBpdGVtW3JlbGF0aW9uLmxvY2FsS2V5XSA/IHJlbGF0aW9uUmVzdWx0IDogaXRlbVtyZWxhdGlvbi5tb2RlbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlbC5SRUxBVElPTlMuaGFzTWFueSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlbGF0aW9uUmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1bcmVsYXRpb24ubW9kZWxOYW1lXSA9IHJlbGF0aW9uUmVzdWx0LmZpbHRlcigocmVsYXRpb25SZXN1bHRJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbGF0aW9uUmVzdWx0SXRlbVtyZWxhdGlvbi5mb3JlaWduS2V5XSA9PSBpdGVtW3JlbGF0aW9uLmxvY2FsS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVsYXRpb25zQ29tcGxldGVkID09IG1vZGVsLnJlbGF0aW9ucy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjcmVhdGVzIGEgc2luZ2xlIHJlY29yZFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgY3JlYXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbW9kZWwuZ2V0VHJhbnNhY3Rpb24obW9kZWwudGFibGVzLCBNb2RlbC5SRUFEV1JJVEUpO1xuXG4gICAgICAgICAgICBsZXQgb2JqID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUobW9kZWwubmFtZSk7XG5cbiAgICAgICAgICAgIGRhdGEuY3JlYXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGRhdGEudXBkYXRlZEF0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBvYmouYWRkKGRhdGEpO1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZGF0YVttb2RlbC5wcmltYXJ5XSA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNyZWF0ZXMgbGlzdCBvZiByZWNvcmRzIHBhc3NlZFxuICAgICAqIEBwYXJhbSBkYXRhUmVjb3Jkc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGNyZWF0ZU11bHRpcGxlIChkYXRhUmVjb3Jkcykge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb24gPSBtb2RlbC5nZXRUcmFuc2FjdGlvbihtb2RlbC50YWJsZXMsIE1vZGVsLlJFQURXUklURSk7XG5cbiAgICAgICAgICAgIGxldCBvYmogPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShtb2RlbC5uYW1lKTtcbiAgICAgICAgICAgIGxldCBjcmVhdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGRhdGFSZWNvcmRzLmZvckVhY2goKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBkYXRhLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcbiAgICAgICAgICAgICAgICBkYXRhLnVwZGF0ZWRBdCA9IHVwZGF0ZWRBdDtcblxuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gb2JqLmFkZChkYXRhKTtcblxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVttb2RlbC5wcmltYXJ5XSA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQubGVuZ3RoID09PSBkYXRhUmVjb3Jkcy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVwZGF0ZXMgdGhlIHZhcmlvdXMgcmVjb3JkcyB3aXRoIG1hdGNoaW5nIHZhbHVlc1xuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgdXBkYXRlKGRhdGEpIHtcblxuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzO1xuICAgICAgICBsZXQgdXBkYXRlZEF0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbW9kZWwuZ2V0VHJhbnNhY3Rpb24obW9kZWwudGFibGVzLCBNb2RlbC5SRUFEV1JJVEUpO1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QsIHRvdGFsUmVjb3Jkc0JlaW5nVXBkYXRlZCA9IDAsIHRvdGFsUmVjb3Jkc1VwZGF0ZWQgPSAwO1xuXG4gICAgICAgICAgICBpZihtb2RlbC5pbmRleEJ1aWxkZXIudHlwZSl7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG1vZGVsLmdldEluZGV4UmVzdWx0KG9iaik7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gb2JqLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICBpZihjdXJzb3Ipe1xuICAgICAgICAgICAgICAgICAgICBpZihtb2RlbC5jaGVja0J1aWxkZXJWYWx1ZShjdXJzb3IudmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmVjb3Jkc0JlaW5nVXBkYXRlZCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSBjdXJzb3IudmFsdWVbbW9kZWwucHJpbWFyeV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3JlYXRlZEF0ID0gY3Vyc29yLnZhbHVlLmNyZWF0ZWRBdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IE1vZGVsLmhlbHBlcnMucmVwbGFjZU5lc3RlZFZhbHVlcyhkYXRhLCBjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W21vZGVsLnByaW1hcnldID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVwZGF0ZWRBdCA9IHVwZGF0ZWRBdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZVJlcXVlc3QgPSBjdXJzb3IudXBkYXRlKHJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxSZWNvcmRzVXBkYXRlZCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodG90YWxSZWNvcmRzVXBkYXRlZCA9PT0gdG90YWxSZWNvcmRzQmVpbmdVcGRhdGVkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1cGRhdGVzIHRoZSByZWNvcmQgYXQgdGhlIGdpdmVuIGlkXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzYXZlKGlkLCBkYXRhKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG4gICAgICAgIGxldCB1cGRhdGVkQXQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIG1vZGVsLmZpbmQoaWQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYoIXJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgnTm8gcmVjb3JkIGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbW9kZWwuZ2V0VHJhbnNhY3Rpb24obW9kZWwudGFibGVzLCBNb2RlbC5SRUFEV1JJVEUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGxldCBvYmogPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShtb2RlbC5uYW1lKTtcblxuICAgICAgICAgICAgICAgIGxldCBpZCA9IHJlc3VsdFttb2RlbC5wcmltYXJ5XTtcbiAgICAgICAgICAgICAgICBsZXQgY3JlYXRlZEF0ID0gcmVzdWx0LmNyZWF0ZWRBdDtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1vZGVsLmhlbHBlcnMucmVwbGFjZU5lc3RlZFZhbHVlcyhkYXRhLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFttb2RlbC5wcmltYXJ5XSA9IGlkO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jcmVhdGVkQXQgPSBjcmVhdGVkQXQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVwZGF0ZWRBdCA9IHVwZGF0ZWRBdDtcblxuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gb2JqLnB1dChyZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGRlbGV0ZXMgdGhlIGVudHJpZXMgYXQgdGhlIGdpdmVuIHBvaW50XG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgZGVzdHJveUlkKGlkKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG5cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbW9kZWwuZmluZChpZCkudGhlbigocmVzdWx0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZighcmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdyZXN1bHQgYXQgaWQgZG9lcyBub3QgZXhpc3RzJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbW9kZWwuZ2V0VHJhbnNhY3Rpb24obW9kZWwudGFibGVzLCBNb2RlbC5SRUFEV1JJVEUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGxldCBvYmogPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShtb2RlbC5uYW1lKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdCA9IG9iai5kZWxldGUoaWQpO1xuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gZGVsZXRlcyB0aGUgZW50cmllc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRFdSSVRFKTtcbiAgICAgICAgICAgIGxldCBvYmogPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShtb2RlbC5uYW1lKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0LCB0b3RhbFJlY29yZHNCZWluZ0RlbGV0ZWQgPSAwLCB0b3RhbFJlY29yZHNEZWxldGVkID0gMDtcblxuICAgICAgICAgICAgaWYgKG1vZGVsLmluZGV4QnVpbGRlci50eXBlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG1vZGVsLmdldEluZGV4UmVzdWx0KG9iaik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBvYmoub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmNoZWNrQnVpbGRlclZhbHVlKGN1cnNvci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmVjb3Jkc0JlaW5nRGVsZXRlZCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVsZXRlUmVxdWVzdCA9IGN1cnNvci5kZWxldGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxSZWNvcmRzRGVsZXRlZCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsUmVjb3Jkc0RlbGV0ZWQgPT09IHRvdGFsUmVjb3Jkc0JlaW5nRGVsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjb3VudHMgdGhlIG51bWJlciBvZiByZWNvcmRzXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgY291bnQoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRE9OTFkpO1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdDtcblxuICAgICAgICAgICAgaWYobW9kZWwuaW5kZXhCdWlsZGVyLnR5cGUpe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBtb2RlbC5nZXRJbmRleFJlc3VsdChvYmopO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG9iai5vcGVuQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYoY3Vyc29yKXtcbiAgICAgICAgICAgICAgICAgICAgaWYobW9kZWwuY2hlY2tCdWlsZGVyVmFsdWUoY3Vyc29yLnZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBhdmVyYWdlcyB0aGUgbnVtZXJpYyB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcG9pbnRcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXZlcmFnZSAoYXR0cmlidXRlKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRE9OTFkpO1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDAsIHRvdGFsUmVjb3JkcyA9IDA7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdDtcblxuICAgICAgICAgICAgaWYobW9kZWwuaW5kZXhCdWlsZGVyLnR5cGUpe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBtb2RlbC5nZXRJbmRleFJlc3VsdChvYmopO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG9iai5vcGVuQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYoY3Vyc29yKXtcbiAgICAgICAgICAgICAgICAgICAgaWYobW9kZWwuY2hlY2tCdWlsZGVyVmFsdWUoY3Vyc29yLnZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFJlY29yZHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wUmVzdWx0ID0gTW9kZWwuaGVscGVycy5nZXROZXN0ZWRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFJlc3VsdCA9IHBhcnNlRmxvYXQodGVtcFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUmVzdWx0ID0gaXNOYU4odGVtcFJlc3VsdCkgPyAwIDogdGVtcFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZW1wUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG5cbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQvdG90YWxSZWNvcmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2UgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggZWFjaCBwYXNzaW5nIGl0ZXJhdG9yIHZhbHVlIGFuZCByZWR1Y2VkIHZhbHVlIGlzIHJldHVybmVkXG4gICAgICogQHBhcmFtIGZ1bmNcbiAgICAgKiBAcGFyYW0gZGVmYXVsdENhcnJ5XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgcmVkdWNlIChmdW5jLCBkZWZhdWx0Q2FycnkpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcztcblxuICAgICAgICBpZih0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICB0aHJvdyBcIlBhcmFtZXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbiB0eXBlXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbW9kZWwuZ2V0VHJhbnNhY3Rpb24obW9kZWwudGFibGVzLCBNb2RlbC5SRUFET05MWSk7XG4gICAgICAgICAgICBsZXQgb2JqID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUobW9kZWwubmFtZSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZGVmYXVsdENhcnJ5O1xuICAgICAgICAgICAgbGV0IHJlcXVlc3Q7XG5cbiAgICAgICAgICAgIGlmKG1vZGVsLmluZGV4QnVpbGRlci50eXBlKXtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbW9kZWwuZ2V0SW5kZXhSZXN1bHQob2JqKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBvYmoub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmKGN1cnNvcil7XG4gICAgICAgICAgICAgICAgICAgIGlmKG1vZGVsLmNoZWNrQnVpbGRlclZhbHVlKGN1cnNvci52YWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyhjdXJzb3IudmFsdWUsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcblxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5kZXggc2VhcmNoIGNyaXRlcmlhXG4gICAgICogQHBhcmFtIG9iamVjdFN0b3JlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0SW5kZXhSZXN1bHQob2JqZWN0U3RvcmUpIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSB0aGlzO1xuICAgICAgICBsZXQgcmFuZ2U7XG4gICAgICAgIGxldCBpbmRleDtcblxuXG4gICAgICAgIGlmKCFidWlsZGVyLmluZGV4QnVpbGRlci50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0U3RvcmUub3BlbkN1cnNvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYnVpbGRlci5pbmRleEJ1aWxkZXIuaW5kZXggIT09IGJ1aWxkZXIucHJpbWFyeSl7XG4gICAgICAgICAgICBpbmRleCA9IG9iamVjdFN0b3JlLmluZGV4KGJ1aWxkZXIuaW5kZXhCdWlsZGVyLmluZGV4KTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBpbmRleCA9IG9iamVjdFN0b3JlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChidWlsZGVyLmluZGV4QnVpbGRlci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhbmQnIDpcbiAgICAgICAgICAgICAgICByYW5nZSA9IGJ1aWxkZXIuaWRiS2V5Lm9ubHkoYnVpbGRlci5pbmRleEJ1aWxkZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdpbicgOlxuICAgICAgICAgICAgICAgIGJ1aWxkZXIud2hlcmVJbihidWlsZGVyLmluZGV4QnVpbGRlci5pbmRleCwgYnVpbGRlci5pbmRleEJ1aWxkZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBidWlsZGVyLmluZGV4QnVpbGRlci52YWx1ZS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBidWlsZGVyLmlkYktleS5ib3VuZCh2YWx1ZXNbMF0sIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2d0ZScgOlxuICAgICAgICAgICAgICAgIHJhbmdlID0gYnVpbGRlci5pZGJLZXkubG93ZXJCb3VuZChidWlsZGVyLmluZGV4QnVpbGRlci52YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdndCcgOlxuICAgICAgICAgICAgICAgIHJhbmdlID0gYnVpbGRlci5pZGJLZXkubG93ZXJCb3VuZChidWlsZGVyLmluZGV4QnVpbGRlci52YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2x0ZScgOlxuICAgICAgICAgICAgICAgIHJhbmdlID0gYnVpbGRlci5pZGJLZXkudXBwZXJCb3VuZChidWlsZGVyLmluZGV4QnVpbGRlci52YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdsdCcgOlxuICAgICAgICAgICAgICAgIHJhbmdlID0gYnVpbGRlci5pZGJLZXkubG93ZXJCb3VuZChidWlsZGVyLmluZGV4QnVpbGRlci52YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JldHdlZW4nIDpcbiAgICAgICAgICAgICAgICByYW5nZSA9IGJ1aWxkZXIuaWRiS2V5LmJvdW5kKGJ1aWxkZXIuaW5kZXhCdWlsZGVyLnZhbHVlWzBdLCBidWlsZGVyLmluZGV4QnVpbGRlci52YWx1ZVsxXSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIGJ1aWxkZXIgdHlwZSBmb3VuZCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXgub3BlbkN1cnNvcihyYW5nZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGNvbW1vbiBzZWFyY2ggY3JpdGVyaWEgb3RoZXIgdGhhbiB0aGUgaW5kZXggdmFsdWVzXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2hlY2tCdWlsZGVyVmFsdWUodmFsdWUpIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSB0aGlzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGksajtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJ1aWxkZXIuYnVpbGRlci5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgICAgIGxldCBjb25kaXRpb24gPSBidWlsZGVyLmJ1aWxkZXJbaV07XG4gICAgICAgICAgICBzd2l0Y2goY29uZGl0aW9uLnR5cGUpe1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYW5kJyA6IC8vY2FzZSBmb3Igb25lIHRvIG9uZSBzZWFyY2hcbiAgICAgICAgICAgICAgICAgICAgaWYoIU1vZGVsLmhlbHBlcnMuY2hlY2tOZXN0ZWRBdHRyaWJ1dGUoY29uZGl0aW9uLmF0dHJpYnV0ZSwgdmFsdWUsIGNvbmRpdGlvbi52YWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaW4nIDogLy9jYXNlIGZvciBsaXN0IHNlYXJjaFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcENoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IGNvbmRpdGlvbi52YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gTW9kZWwuaGVscGVycy5jaGVja05lc3RlZEF0dHJpYnV0ZShjb25kaXRpb24uYXR0cmlidXRlLCB2YWx1ZSwgY29uZGl0aW9uLnZhbHVlW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQ2hlY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIXRlbXBDaGVjayl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3RlJyA6IC8vY2FzZSBmb3IgY2hlY2tpbmcgdGhlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBpcyBlcXVhbCB0byB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBNb2RlbC5oZWxwZXJzLmdldE5lc3RlZEF0dHJpYnV0ZShjb25kaXRpb24uYXR0cmlidXRlLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA8IGNvbmRpdGlvbi52YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2d0JyA6IC8vY2FzZSBmb3IgY2hlY2tpbmcgdGhlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc2FtZVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1vZGVsLmhlbHBlcnMuZ2V0TmVzdGVkQXR0cmlidXRlKGNvbmRpdGlvbi5hdHRyaWJ1dGUsIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0IDw9IGNvbmRpdGlvbi52YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2x0ZScgOiAvL2Nhc2UgZm9yIGNoZWNraW5nIHRoZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgaXMgZXF1YWwgdG8gdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gTW9kZWwuaGVscGVycy5nZXROZXN0ZWRBdHRyaWJ1dGUoY29uZGl0aW9uLmF0dHJpYnV0ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPiBjb25kaXRpb24udmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbHQnIDogLy9jYXNlIGZvciBjaGVja2luZyB0aGUgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1vZGVsLmhlbHBlcnMuZ2V0TmVzdGVkQXR0cmlidXRlKGNvbmRpdGlvbi5hdHRyaWJ1dGUsIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID49IGNvbmRpdGlvbi52YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdiZXR3ZWVuJyA6IC8vY2FzZSBmb3IgY2hlY2tpbmcgdGhlIHZhbHVlIGlzIGJldHdlZW4gdGhlIGdpdmVuIHJhbmdlKE9OTFkgV09SS1MgRk9SIE5VTUVSSUMpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1vZGVsLmhlbHBlcnMuZ2V0TmVzdGVkQXR0cmlidXRlKGNvbmRpdGlvbi5hdHRyaWJ1dGUsIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoY29uZGl0aW9uLnZhbHVlWzBdID49IHJlc3VsdCAmJiBjb25kaXRpb24udmFsdWVbMV0gPD0gcmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHRhYmxlc1xuICAgICAqIEBwYXJhbSBtb2RlXG4gICAgICovXG4gICAgY3JlYXRlVHJhbnNhY3Rpb24odGFibGVzLCBtb2RlKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKHRhYmxlcywgbW9kZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIElEQlRyYW5zYWN0aW9uIG9iZWpjdCB0byBjdXJyZW50IG1vZGVsIHNjb3BlXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgc2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSURCVHJhbnNhY3Rpb24gb2JqZWN0IHNldCBpbiBjdXJyZW50IHNjb3BlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdGFibGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZVxuICAgICAqIEByZXR1cm5zIHsqfG51bGx9XG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb24odGFibGVzLCBtb2RlLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgb3ZlcndyaXRlID0gb3ZlcndyaXRlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG92ZXJ3cml0ZTtcblxuICAgICAgICBpZighdGhpcy50cmFuc2FjdGlvbiB8fCBvdmVyd3JpdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVHJhbnNhY3Rpb24odGFibGVzLCBtb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IG9yIGRpcmVjdCBrZXkgdmFsdWUgYWdhaW5zdCB0aGUgaW5wdXQgZ2l2ZSBmb3IgdGhlIGtleSBzcGVjaWZpZWRcbiAgICAgKiBAcGFyYW0gcmVzdWx0XG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSBpc0FycmF5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0TWFpblJlc3VsdCAocmVzdWx0LCBrZXksIGlzQXJyYXkpIHtcbiAgICAgICAgaWYoaXNBcnJheSl7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0W2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgcmVsYXRpb25zaGlwcyBhc3NpZ25lZCB3aXRoIGJ1aWxkZXIgYW5kIGZldGNoZXMgdGhlbVxuICAgICAqIEBwYXJhbSByZWxhdGlvblxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBtYWluUmVzdWx0XG4gICAgICogQHBhcmFtIGlzQXJyYXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBnZXRSZWxhdGlvbnNoaXBzIChyZWxhdGlvbiwgdHJhbnNhY3Rpb24sIG1haW5SZXN1bHQsIGlzQXJyYXkpIHtcblxuICAgICAgICBpc0FycmF5ID0gaXNBcnJheSB8fCBmYWxzZTtcblxuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzO1xuICAgICAgICBsZXQgcHJpbWFyeSA9IHJlbGF0aW9uLnByaW1hcnkgfHwgJ2lkJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHZhciBNb2RlbCByZWxhdGlvbk1vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgcmVsYXRpb25Nb2RlbCA9IG5ldyBNb2RlbChtb2RlbC5kYiwgbW9kZWwuaWRiS2V5LCByZWxhdGlvbi5tb2RlbE5hbWUsIHJlbGF0aW9uLnByaW1hcnkpO1xuXG4gICAgICAgIC8vc2V0dGluZyB0aGUgcmVsYXRpb24gdHJhbnNhY3Rpb24gc2FtZSBhcyBwYXJlbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgcmVsYXRpb25Nb2RlbC5zZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG5cbiAgICAgICAgLy9pZiBhIHNlY29uZHJ5IGJ1aWxkZXIgZnVuY3Rpb24gd2FzIGRlZmluZWRcbiAgICAgICAgaWYocmVsYXRpb24uZnVuYyl7XG4gICAgICAgICAgICBsZXQgdGVtcEJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuXG4gICAgICAgICAgICB0ZW1wQnVpbGRlciA9IHJlbGF0aW9uLmZ1bmModGVtcEJ1aWxkZXIpO1xuXG4gICAgICAgICAgICByZWxhdGlvbk1vZGVsLnRhYmxlcyA9IHRlbXBCdWlsZGVyLnRhYmxlcztcbiAgICAgICAgICAgIHJlbGF0aW9uTW9kZWwudGFibGVzLnB1c2gocmVsYXRpb25Nb2RlbC5uYW1lKTtcbiAgICAgICAgICAgIHJlbGF0aW9uTW9kZWwucmVsYXRpb25zID0gdGVtcEJ1aWxkZXIucmVsYXRpb25zO1xuICAgICAgICAgICAgcmVsYXRpb25Nb2RlbC5idWlsZGVyID0gdGVtcEJ1aWxkZXIuYnVpbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2tpbmcgdHlwZSBvZiBwYXJlbnQgcmVzdWx0XG4gICAgICAgIGlmKGlzQXJyYXkpe1xuICAgICAgICAgICAgcmVsYXRpb25Nb2RlbC53aGVyZUluZGV4SW4ocmVsYXRpb24uZm9yZWlnbktleSwgbWFpblJlc3VsdCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmVsYXRpb25Nb2RlbC53aGVyZUluZGV4KHJlbGF0aW9uLmZvcmVpZ25LZXksIG1haW5SZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZWxhdGlvblJlc29sdmUsIHJlbGF0aW9uUmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vaWYgcmVsYXRpb24gdHlwZSBtZW50aW9uZWRcbiAgICAgICAgICAgIHN3aXRjaCAocmVsYXRpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZWwuUkVMQVRJT05TLmhhc09uZSA6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlbGF0aW9uTW9kZWwuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlbC5SRUxBVElPTlMuaGFzTWFueSA6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlbGF0aW9uTW9kZWwuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgcmVsYXRpb24gdHlwZSBwcm92aWRlZFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQudGhlbihyID0+IHtcbiAgICAgICAgICAgICAgICByZWxhdGlvblJlc29sdmUocik7XG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHJlbGF0aW9uUmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHJlc3VsdC4gTnVsbCBmb3IgaGFzT25lIGFuZCBhcnJheSBmb3IgaGFzTWFueVxuICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFJlbGF0aW9uVmFsdWUodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIE1vZGVsLlJFTEFUSU9OUy5oYXNPbmUgOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgTW9kZWwuUkVMQVRJT05TLmhhc01hbnkgOlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuXG4gICAgLyoqXG4gICAgICogUmVhZHdyaXRlIHBhcmFtZXRlciBvZiBpbmRleGVkREJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBSRUFEV1JJVEUoKSB7XG4gICAgICAgIHJldHVybiBcInJlYWR3cml0ZVwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRvbmx5IHBhcmFtZXRlciBvZiBpbmRleGVkREJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBSRUFET05MWSgpIHtcbiAgICAgICAgcmV0dXJuIFwicmVhZG9ubHlcIjtcbiAgICB9XG5cbn1cblxuY2xhc3MgTWlncmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihkYiwgdHJhbnNhY3Rpb24sIG1pZ3JhdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB2YXIgSURCRGF0YWJhc2UgZGJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5taWdyYXRpb25zID0gbWlncmF0aW9ucztcbiAgICAgICAgdGhpcy5vYmplY3RTdG9yZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHZhciBJREJUcmFuc2FjdGlvbiB0cmFuc2FjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgIH1cblxuICAgIGNyZWF0ZVN0b3JlKHNjaGVtYSkge1xuICAgICAgICBsZXQgbWlnID0gdGhpcztcbiAgICAgICAgbGV0IHByaW1hcnkgPSBzY2hlbWEucHJpbWFyeSB8fCAnaWQnO1xuXG4gICAgICAgIGxldCBvYmplY3RTdG9yZSA9IG1pZy5kYi5jcmVhdGVPYmplY3RTdG9yZShzY2hlbWEubmFtZSwge2tleVBhdGg6IHByaW1hcnksIGF1dG9JbmNyZW1lbnQ6IHRydWV9KTtcbiAgICAgICAgbWlnLm9iamVjdFN0b3Jlcy5wdXNoKG9iamVjdFN0b3JlKTtcblxuICAgICAgICBpZiAoc2NoZW1hLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHNjaGVtYS5jb2x1bW5zLmZvckVhY2goKGNvbHVtbikgPT4gbWlnLm1ha2VJbmRleChjb2x1bW4sIG9iamVjdFN0b3JlKSk7XG4gICAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgcnVuKCkge1xuICAgICAgICBsZXQgbWlnID0gdGhpcztcblxuICAgICAgICBtaWcubWlncmF0aW9ucy5mb3JFYWNoKChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGlmKG1pZy5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHNjaGVtYS5uYW1lKSl7XG5cbiAgICAgICAgICAgICAgICBpZihzY2hlbWEuZHJvcCl7XG4gICAgICAgICAgICAgICAgICAgIG1pZy5kYi5kZWxldGVPYmplY3RTdG9yZShzY2hlbWEubmFtZSk7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIG1pZy51cGRhdGVTdG9yZShzY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBtaWcuY3JlYXRlU3RvcmUoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWFrZUluZGV4KGNvbHVtbiwgb2JqZWN0U3RvcmUpIHtcbiAgICAgICAgY29sdW1uLmF0dHJpYnV0ZXMgPSBjb2x1bW4uYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgY29sdW1uLmluZGV4ID0gY29sdW1uLmluZGV4IHx8IGNvbHVtbi5uYW1lO1xuICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleChjb2x1bW4ubmFtZSwgY29sdW1uLmluZGV4LCBjb2x1bW4uYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlU3RvcmUoc2NoZW1hKSB7XG4gICAgICAgIGxldCBtaWcgPSB0aGlzO1xuXG4gICAgICAgIGxldCBvYmplY3RTdG9yZSA9IG1pZy50cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzY2hlbWEubmFtZSk7XG5cbiAgICAgICAgaWYgKHNjaGVtYS5jb2x1bW5zKSB7XG5cbiAgICAgICAgICAgIHNjaGVtYS5jb2x1bW5zLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmKCFvYmplY3RTdG9yZS5pbmRleE5hbWVzLmNvbnRhaW5zKGNvbHVtbi5uYW1lKSl7XG4gICAgICAgICAgICAgICAgICAgIG1pZy5tYWtlSW5kZXgoY29sdW1uLCBvYmplY3RTdG9yZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNjaGVtYS5kcm9wQ29sdW1ucykge1xuICAgICAgICAgICAgc2NoZW1hLmRyb3BDb2x1bW5zLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmKG9iamVjdFN0b3JlLmluZGV4TmFtZXMuY29udGFpbnMoY29sdW1uKSl7XG4gICAgICAgICAgICAgICAgICAgIG1pZy5kcm9wSW5kZXgoY29sdW1uLCBvYmplY3RTdG9yZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRyb3BJbmRleChjb2x1bW5OYW1lLCBvYmplY3RTdG9yZSkge1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgb2JqZWN0U3RvcmUuZGVsZXRlSW5kZXgoY29sdW1uTmFtZSk7XG4gICAgfVxuXG59XG5cblxuXG5sZXQgZGIsIG1vZGVscztcbmxldCBlcnJvck5hbWVzcGFjZSA9ICctZXJyb3InO1xuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIEpTT04ucGFyc2UoZS5kYXRhLmRldGFpbCk7XG4gICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKGUuZGF0YS5kZXRhaWwsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJyl7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICggdmFsdWUuaW5kZXhPZignZnVuY3Rpb24nKSA+PSAwIHx8IHZhbHVlLmluZGV4T2YoJz0+JykgPj0gMCkgPyBldmFsKCcoJyt2YWx1ZSsnKScpIDogdmFsdWU7XG4gICAgfSk7XG4gICAgc2VsZi5lbWl0KGRhdGEsIGUuZGF0YS50aW1lc3RhbXAsIGUuZGF0YS5hY3Rpb24sIGUuZGF0YS5tb2RlbCk7XG59KTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdpZGI6d29ya2VyOmluaXRpYWxpemUnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IGlkYiA9IHNlbGYuaW5kZXhlZERCIHx8IHNlbGYubW96SW5kZXhlZERCIHx8IHNlbGYud2Via2l0SW5kZXhlZERCIHx8IHNlbGYubXNJbmRleGVkREI7XG4gICAgbGV0IGlkYktleSA9IHNlbGYuSURCS2V5UmFuZ2UgfHwgc2VsZi53ZWJraXRJREJLZXlSYW5nZSB8fCBzZWxmLm1zSURCS2V5UmFuZ2U7XG5cbiAgICBkYiA9IG5ldyBEQihpZGIsIGlkYktleSwgZS5kZXRhaWwuZGV0YWlsLCBmYWxzZSk7XG5cbiAgICBkYi5jb25uZWN0KClcbiAgICAgICAgLnRoZW4oKG0pID0+IHtcbiAgICAgICAgICAgIG1vZGVscyA9IG07XG4gICAgICAgICAgICBzZWxmLnNlbmQodHJ1ZSwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHNlbGYuc2VuZChmYWxzZSwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24pKTtcblxufSk7XG5cbnNlbGYuZW1pdCA9IGZ1bmN0aW9uIChkYXRhLCB0aW1lc3RhbXAsIGFjdGlvbiwgbW9kZWwpIHtcbiAgICBsZXQgZXYgPSBuZXcgc2VsZi5DdXN0b21FdmVudCgnaWRiOndvcmtlcjonICsgYWN0aW9uLCB7XG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgZGV0YWlsOiBkYXRhLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIG1vZGVsOiBtb2RlbFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXYpO1xufTtcblxuc2VsZi5zZW5kID0gZnVuY3Rpb24gKGRhdGEsIHRpbWVzdGFtcCwgYWN0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgZXYgPSB7XG4gICAgICAgIGRldGFpbDogZGF0YSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgIH07XG5cbiAgICBzZWxmLnBvc3RNZXNzYWdlKGV2KTtcbn07XG5cblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdpZGI6d29ya2VyOmNyZWF0ZScsIChlKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgbSA9IG1vZGVsc1tlLmRldGFpbC5tb2RlbF07XG5cbiAgICBtLmNyZWF0ZShlLmRldGFpbC5kZXRhaWwpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChlciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjpmaW5kJywgKGUpID0+IHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGxldCBtID0gbW9kZWxzW2UuZGV0YWlsLm1vZGVsXTtcbiAgICBtLmJ1aWxkZXIgPSBlLmRldGFpbC5kZXRhaWwuYnVpbGRlcjtcbiAgICBtLmluZGV4QnVpbGRlciA9IGUuZGV0YWlsLmRldGFpbC5pbmRleEJ1aWxkZXI7XG4gICAgbS50YWJsZXMgPSBlLmRldGFpbC5kZXRhaWwudGFibGVzO1xuICAgIG0ucmVsYXRpb25zID0gZS5kZXRhaWwuZGV0YWlsLnJlbGF0aW9ucztcblxuICAgIG0uZmluZChlLmRldGFpbC5kZXRhaWwpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChlciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjpjcmVhdGVNdWx0aXBsZScsIChlKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgbSA9IG1vZGVsc1tlLmRldGFpbC5tb2RlbF07XG4gICAgbS5jcmVhdGVNdWx0aXBsZShlLmRldGFpbC5kZXRhaWwpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChlciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjpnZXQnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IG0gPSBtb2RlbHNbZS5kZXRhaWwubW9kZWxdO1xuICAgIG0uYnVpbGRlciA9IGUuZGV0YWlsLmRldGFpbC5idWlsZGVyO1xuICAgIG0uaW5kZXhCdWlsZGVyID0gZS5kZXRhaWwuZGV0YWlsLmluZGV4QnVpbGRlcjtcbiAgICBtLnRhYmxlcyA9IGUuZGV0YWlsLmRldGFpbC50YWJsZXM7XG4gICAgbS5yZWxhdGlvbnMgPSBlLmRldGFpbC5kZXRhaWwucmVsYXRpb25zO1xuXG4gICAgbS5nZXQoZS5kZXRhaWwuZGV0YWlsKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2lkYjp3b3JrZXI6Zmlyc3QnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IG0gPSBtb2RlbHNbZS5kZXRhaWwubW9kZWxdO1xuICAgIG0uYnVpbGRlciA9IGUuZGV0YWlsLmRldGFpbC5idWlsZGVyO1xuICAgIG0uaW5kZXhCdWlsZGVyID0gZS5kZXRhaWwuZGV0YWlsLmluZGV4QnVpbGRlcjtcbiAgICBtLnRhYmxlcyA9IGUuZGV0YWlsLmRldGFpbC50YWJsZXM7XG4gICAgbS5yZWxhdGlvbnMgPSBlLmRldGFpbC5kZXRhaWwucmVsYXRpb25zO1xuXG4gICAgbS5maXJzdChlLmRldGFpbC5kZXRhaWwpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXJyLCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbiArIGVycm9yTmFtZXNwYWNlKTtcbiAgICAgICAgfSk7XG59KTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdpZGI6d29ya2VyOnVwZGF0ZScsIChlKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgbSA9IG1vZGVsc1tlLmRldGFpbC5tb2RlbF07XG5cbiAgICBtLnVwZGF0ZShlLmRldGFpbC5kZXRhaWwpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChlciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjpzYXZlJywgKGUpID0+IHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGxldCBtID0gbW9kZWxzW2UuZGV0YWlsLm1vZGVsXTtcblxuICAgIG0uc2F2ZShlLmRldGFpbC5kZXRhaWwuaWQsIGUuZGV0YWlsLmRldGFpbC5kYXRhKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2lkYjp3b3JrZXI6Y291bnQnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IG0gPSBtb2RlbHNbZS5kZXRhaWwubW9kZWxdO1xuXG4gICAgbS5jb3VudCgpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChlciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjphdmVyYWdlJywgKGUpID0+IHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGxldCBtID0gbW9kZWxzW2UuZGV0YWlsLm1vZGVsXTtcblxuICAgIG0uYXZlcmFnZShlLmRldGFpbC5kZXRhaWwpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChlciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG5cblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdpZGI6d29ya2VyOnJlZHVjZScsIChlKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgbSA9IG1vZGVsc1tlLmRldGFpbC5tb2RlbF07XG5cbiAgICBtLnJlZHVjZShlLmRldGFpbC5kZXRhaWwuZnVuYywgZS5kZXRhaWwuZGV0YWlsLmRlZmF1bHRDYXJyeSlcbiAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5zZW5kKHJlc3VsdCwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXIgPT4ge1xuICAgICAgICAgICAgc2VsZi5zZW5kKGVyLCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbiArIGVycm9yTmFtZXNwYWNlKTtcbiAgICAgICAgfSk7XG59KTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdpZGI6d29ya2VyOmRlc3Ryb3lJZCcsIChlKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgbSA9IG1vZGVsc1tlLmRldGFpbC5tb2RlbF07XG5cbiAgICBtLmRlc3Ryb3lJZChlLmRldGFpbC5kZXRhaWwpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChlciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjpkZXN0cm95JywgKGUpID0+IHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGxldCBtID0gbW9kZWxzW2UuZGV0YWlsLm1vZGVsXTtcblxuICAgIG0uZGVzdHJveSgpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChlciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXIuanMubWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYnVpbGQvd29ya2VyLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBREE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7OztBQWw2QkE7QUFDQTtBQW82QkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ]);