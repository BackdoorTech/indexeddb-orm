/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

eval("var DB = function DB(idb, idbKey, settings, useWebWorker, pathToWebWorker) {\n    this.db = idb;\n    this.idbKey = idbKey;\n    this.settings = settings;\n    this.useWebWorker = useWebWorker || false;\n    this.isWebWorker = false;\n    this.pathToWebWorker = pathToWebWorker;\n};\n\n/**\n * Initializes database connection with indexedDB\n *\n * @returns {Promise}\n */\nDB.prototype.connect = function connect () {\n    var db = this;\n    return new Promise(function (resolve, reject) {\n\n        if(db.useWebWorker){\n            db.createWorkerHandler(resolve, reject);\n        }else{\n            db.createNormalHandler(resolve, reject);\n        }\n    });\n};\n\n/**\n * Destroys/Deletes the databaase\n * @param dbName\n */\nDB.prototype.destroy = function destroy (dbName) {\n    console.info('database ' + dbName + ' deleted');\n    this.db.deleteDatabase(dbName);\n};\n\n/**\n * Creates connection in web worker space and if web worker fails\n * then creates normal database connection instance\n * @param resolve\n * @param reject\n */\nDB.prototype.createWorkerHandler = function createWorkerHandler (resolve, reject) {\n    var db = this;\n    try{\n        var worker = new window.Worker(db.pathToWebWorker);\n        var models = {};\n        var timestamp = Date.now();\n\n        worker.postMessage({\n            detail : JSON.stringify(db.settings),\n            action : 'initialize',\n            timestamp : timestamp\n        });\n            \n        worker.onmessage = function (e) {\n            if(e.data.action === 'initialize' && e.data.timestamp === timestamp) {\n                if (e.data.detail === true) {\n                    db.settings.migrations.forEach(function (schema) {\n                        Object.defineProperty(models, schema.name, {\n                            get: function get() {\n                                return new WorkerModelHandler(schema.name, worker, window);\n                            }\n                        });\n                    });\n\n                    db.isWebWorker = true;\n                    resolve(models);\n                } else {\n                    db.createNormalHandler(resolve, reject);\n                }\n            }\n        }\n\n    }catch (e) {\n        reject(e);\n    }\n\n};\n\n/**\n * Creates normal database instance and models\n * @param resolve\n * @param reject\n */\nDB.prototype.createNormalHandler = function createNormalHandler (resolve, reject) {\n    var db = this;\n\n    var request = this.db.open(this.settings.dbName, this.settings.dbVersion);\n\n    request.onupgradeneeded = function (e) {\n        var mig = new Migration(e.target.result, e.target.transaction, db.settings.migrations);\n        mig.run();\n    };\n\n    request.onerror = function (e) {\n        reject(e);\n    };\n\n    request.onsuccess = function (e) {\n        var models = {};\n\n        db.settings.migrations.forEach(function (schema) {\n            var primary = schema.primary || 'id';\n            Object.defineProperty(models, schema.name, {\n                get: function get() {\n                    return new Model(e.target.result, db.idbKey, schema.name, primary);\n                }\n            });\n        });\n\n        resolve(models);\n    };\n};\nvar Builder = function Builder () {\n    this.builder = [];\n    this.indexBuilder = {};\n    this.relations = [];\n    this.tables = [];\n};\n\nvar staticAccessors = { helpers: {},RELATIONS: {} };\n\n/**\n * Sets the index builder value as an 'and' reference\n *\n * @param indexName string\n * @param value mixed\n * @returns {Builder}\n */\nBuilder.prototype.whereIndex = function whereIndex (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'and'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value as an 'in' reference\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.whereIndexIn = function whereIndexIn (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'in'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with point inclusive and sets greater than check\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.indexGte = function indexGte (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'gte'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with point not inclusive and sets greater than check\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.indexGt = function indexGt (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'gt'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with point inclusive and sets less than check\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.indexLte = function indexLte (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'lte'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with point not inclusive and sets less than check\n *\n * @param indexName\n * @param value\n * @returns {Builder}\n */\nBuilder.prototype.indexLt = function indexLt (indexName, value) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : value,\n        type : 'lt'\n    };\n\n    return this;\n};\n\n/**\n * Sets the index builder value with points inclusive and sets range between them\n * @param indexName\n * @param lower\n * @param upper\n * @returns {Builder}\n */\nBuilder.prototype.indexBetween = function indexBetween (indexName, lower, upper) {\n\n    this.indexBuilder = {\n        index : indexName,\n        value : [lower, upper],\n        type : 'between'\n    };\n\n    return this;\n};\n\nBuilder.prototype.whereIn = function whereIn (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'in'\n    });\n\n    return this;\n};\n\nBuilder.prototype.where = function where (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'and'\n    });\n\n    return this;\n};\n\n\nBuilder.prototype.gte = function gte (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'gte'\n    });\n\n    return this;\n};\n\nBuilder.prototype.gt = function gt (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'gt'\n    });\n\n    return this;\n};\n\nBuilder.prototype.lte = function lte (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'lte'\n    });\n\n    return this;\n};\n\nBuilder.prototype.lt = function lt (attributeName, value) {\n    this.builder.push({\n        attribute : attributeName,\n        value : value,\n        type : 'lt'\n    });\n\n    return this;\n};\n\nBuilder.prototype.between = function between (attributeName, upper, lower) {\n    uppper = parseFloat(upper);\n    lower = parseFloat(lower);\n\n    if(isNaN(upper) || isNaN(lower)){\n        throw \"Between is only for numeric values\";\n    }\n\n    this.builder.push({\n        attribute : attributeName,\n        value : [upper, lower],\n        type : 'between'\n    });\n\n    return this;\n};\n\nBuilder.prototype.relation = function relation (modelName, type, localKey, foreignKey, func, primary) {\n    this.tables.push(modelName);\n\n    this.relations.push({\n        modelName : modelName,\n        func : func,\n        localKey : localKey,\n        foreignKey : foreignKey,\n        type : type,\n        primary : primary\n    });\n\n    return this;\n};\n\nstaticAccessors.helpers.get = function () {\n\n    return {\n\n        checkNestedAttribute: function checkNestedAttribute (attributeString, value, condition) {\n            return condition == Model.helpers.getNestedAttribute(attributeString, value)\n        },\n\n        getNestedAttribute: function getNestedAttribute(attributeString, value) {\n            var attributes = attributeString.split('.');\n            var i;\n            var content = value;\n\n            for(i = 0; i < attributes.length; i++) {\n                if(content[attributes[i]] === undefined){\n                    return undefined;\n                }\n\n                content = content[attributes[i]];\n            }\n\n            return content;\n        },\n\n        replaceNestedValues: function replaceNestedValues(attributes, value) {\n            for(var attribute in attributes) {\n                value[attribute] = attributes[attribute];\n            }\n\n            return value;\n        },\n    };\n\n};\n\nstaticAccessors.RELATIONS.get = function () {\n    return {\n        hasOne : 'hasOne',\n        hasMany : 'hasMany'\n    }\n};\n\nObject.defineProperties( Builder, staticAccessors );\nvar Model = (function (Builder) {\n    function Model(db, idbKey, modelName, primary){\n        Builder.call(this);\n\n        this.name = modelName;\n        this.db = db;\n        this.primary = primary;\n        this.tables = [this.name];\n        this.idbKey = idbKey;\n        this.hasIdbKey = this.idbKey ? true : false;\n        this.transaction = null;\n        this.attributes = {};\n    }\n\n    if ( Builder ) Model.__proto__ = Builder;\n    Model.prototype = Object.create( Builder && Builder.prototype );\n    Model.prototype.constructor = Model;\n\n    var staticAccessors$1 = { READWRITE: {},READONLY: {} };\n\n    /**\n     * Finds the result on the primary key defined\n     * @param id\n     * @returns {Promise}\n     */\n    Model.prototype.find = function find (id) {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var request = obj.get(id);\n            \n            request.onsuccess = function (e) {\n                resolve(e.target.result);\n            };\n\n            request.onerror = function (e) {\n                reject(e);\n            };\n\n        });\n    };\n\n    /**\n     * Searches for first value in database and returns that\n     * @returns {Promise}\n     */\n    Model.prototype.first = function first () {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = null;\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        var relationsCompleted = 0;\n\n                        result = cursor.value;\n\n                        if(model.relations.length > 0 && (result !== null || result !== undefined)){\n\n\n                            model.relations.forEach(function (relation) {\n\n                                var relationRequest = model.getRelationships(relation, model.transaction, model.getMainResult(result, relation.localKey, false), false);\n\n                                relationRequest.then(function (relationResult) {\n\n                                    relationsCompleted++;\n\n                                    var defaultValue = model.getDefaultRelationValue(relation.type);\n                                    result[relation.modelName] = result[relation.modelName] || defaultValue;\n\n                                    switch (relation.type) {\n                                        case Model.RELATIONS.hasOne :\n                                            if (relationResult !== undefined) {\n                                                result[relation.modelName] = relationResult[relation.foreignKey] == result[relation.localKey] ? relationResult : result[relation.modelName];\n                                            }\n\n                                            break;\n                                        case Model.RELATIONS.hasMany :\n                                            if (relationResult.length > 0) {\n                                                result[relation.modelName] = relationResult.filter(function (relationResultItem) {\n                                                    return relationResultItem[relation.foreignKey] == result[relation.localKey];\n                                                });\n                                            }\n                                            break;\n                                    }\n\n                                    if (relationsCompleted == model.relations.length) {\n                                        resolve(result);\n                                    }\n\n                                }).catch(function (err) {\n                                    reject(err);\n                                });\n                            });\n                        }else{\n                            resolve(cursor.value);\n                            return false;\n                        }\n                    }else{\n                        cursor.continue();\n                    }\n\n                }else{\n                    resolve(result);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function searches throughout the database and returns a array of result\n     * @returns {Promise}\n     */\n    Model.prototype.get = function get () {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = [];\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        result.push(cursor.value);\n                    }\n                    cursor.continue();\n\n                }else{\n                    var mainResult, relationsCompleted = 0;\n\n                    if(model.relations.length > 0 && result.length > 0){\n\n\n                        model.relations.forEach(function (relation) {\n\n                            var relationRequest = model.getRelationships(relation, model.transaction, model.getMainResult(result, relation.localKey, true), true);\n\n                            relationRequest.then(function (relationResult) {\n\n                                relationsCompleted++;\n\n                                result = result.map(function (item) {\n\n                                    var defaultValue = model.getDefaultRelationValue(relation.type);\n                                    item[relation.modelName] = item[relation.modelName] || defaultValue;\n\n                                    switch (relation.type) {\n                                        case Model.RELATIONS.hasOne :\n                                            if(relationResult !== undefined) {\n                                                item[relation.modelName] = relationResult[relation.foreignKey] == item[relation.localKey] ? relationResult : item[relation.modelName];\n                                            }\n\n                                            break;\n                                        case Model.RELATIONS.hasMany :\n                                            if(relationResult.length > 0) {\n                                                item[relation.modelName] = relationResult.filter(function (relationResultItem) {\n                                                    return relationResultItem[relation.foreignKey] == item[relation.localKey];\n                                                });\n                                            }\n                                            break;\n                                    }\n\n                                    return item;\n                                });\n\n                                if(relationsCompleted == model.relations.length){\n                                    resolve(result);\n                                }\n\n                            }).catch(function (err) {\n                                reject(err);\n                            })\n                        });\n                    }else{\n                        resolve(result);\n                    }\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function creates a single record\n     * @param data\n     * @returns {Promise}\n     */\n    Model.prototype.create = function create (data) {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READWRITE);\n\n            var obj = transaction.objectStore(model.name);\n\n            data.createdAt = Date.now();\n            data.updatedAt = Date.now();\n\n            var request = obj.add(data);\n\n            request.onsuccess = function (e) {\n                data[model.primary] = e.target.result;\n                resolve(data);\n            };\n\n            request.onerror = function (e) {\n                reject(e);\n            };\n        });\n\n    };\n\n    /**\n     * Function creates list of records passed\n     * @param dataRecords\n     * @returns {Promise}\n     */\n    Model.prototype.createMultiple = function createMultiple (dataRecords) {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READWRITE);\n\n            var obj = transaction.objectStore(model.name);\n            var createdAt = Date.now();\n            var updatedAt = Date.now();\n            var result = [];\n\n            dataRecords.forEach(function (data) {\n                data.createdAt = createdAt;\n                data.updatedAt = updatedAt;\n\n                var request = obj.add(data);\n\n                request.onerror = function(e) {\n                    reject(e);\n                };\n\n                request.onsuccess = function(e) {\n                    data[model.primary] = e.target.result;\n\n                    result.push(data);\n\n                    if(result.length === dataRecords.length){\n                        resolve(result);\n                    }\n                };\n            })\n        });\n    };\n\n    /**\n     * Function updates the various records with matching values\n     * @param data\n     * @returns {Promise}\n     */\n    Model.prototype.update = function update (data) {\n\n        var model = this;\n        var updatedAt = Date.now();\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READWRITE);\n            var obj = transaction.objectStore(model.name);\n            var request, totalRecordsBeingUpdated = 0, totalRecordsUpdated = 0;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        totalRecordsBeingUpdated++;\n\n                        var id = cursor.value[model.primary];\n                        var createdAt = cursor.value.createdAt;\n\n                        var result = Model.helpers.replaceNestedValues(data, cursor.value);\n                        result[model.primary] = id;\n                        result.createdAt = createdAt;\n                        result.updatedAt = updatedAt;\n\n                        var updateRequest = cursor.update(result);\n\n                        updateRequest.onsuccess = function() {\n                            totalRecordsUpdated++;\n\n                            if(totalRecordsUpdated === totalRecordsBeingUpdated){\n                                resolve(true);\n                            }\n                        };\n\n                        updateRequest.onerror = function(err) {\n                            transaction.abort();\n                            reject(err);\n                        };\n\n                    }\n                    cursor.continue();\n\n                }else{\n                    resolve();\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function updates the record at the given id\n     * @param id\n     * @param data\n     * @returns {Promise}\n     */\n    Model.prototype.save = function save (id, data) {\n        var model = this;\n        var updatedAt = Date.now();\n\n        return new Promise(function (resolve, reject) {\n\n            model.find(id).then(function (result) {\n\n                if(!result){\n                    reject('No record found');\n                }\n\n                var transaction = model.getTransaction(model.tables, Model.READWRITE, true);\n                var obj = transaction.objectStore(model.name);\n\n                var id = result[model.primary];\n                var createdAt = result.createdAt;\n\n                result = Model.helpers.replaceNestedValues(data, result);\n                result[model.primary] = id;\n                result.createdAt = createdAt;\n                result.updatedAt = updatedAt;\n\n                var request = obj.put(result);\n\n                request.onsuccess = function () {\n                    resolve(true);\n                };\n\n                request.onerror = function(e) {\n                    reject(e);\n                }\n            }).catch(function (err) {\n                reject(err);\n            });\n\n        });\n    };\n\n    /**\n     * Function deletes the entries at the given point\n     * @param id\n     * @returns {Promise}\n     */\n    Model.prototype.destroyId = function destroyId (id) {\n        var model = this;\n\n\n        return new Promise(function (resolve, reject) {\n            model.find(id).then(function (result) {\n\n                if(!result){\n                    reject('result at id does not exists');\n                }\n\n                var transaction = model.getTransaction(model.tables, Model.READWRITE, true);\n                var obj = transaction.objectStore(model.name);\n                var request = obj.delete(id);\n\n                request.onsuccess = function (e) {\n                    resolve(e.target.result);\n                };\n\n                request.onerror = function (e) {\n                    reject(e);\n                };\n            }).catch(function (err) {\n                reject(err);\n            });\n\n\n        });\n    };\n\n    /**\n     * Function deletes the entries\n     * @returns {Promise}\n     */\n    Model.prototype.destroy = function destroy () {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READWRITE);\n            var obj = transaction.objectStore(model.name);\n            var request, totalRecordsBeingDeleted = 0, totalRecordsDeleted = 0;\n\n            if (model.indexBuilder.type) {\n                request = model.getIndexResult(obj);\n            } else {\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if (cursor) {\n                    if (model.checkBuilderValue(cursor.value)) {\n                        totalRecordsBeingDeleted++;\n\n                        var deleteRequest = cursor.delete();\n\n                        deleteRequest.onsuccess = function () {\n                            totalRecordsDeleted++;\n\n                            if (totalRecordsDeleted === totalRecordsBeingDeleted) {\n                                resolve(true);\n                            }\n                        };\n\n                        deleteRequest.onerror = function (err) {\n                            transaction.abort();\n                            reject(err);\n                        };\n\n                    }\n                    cursor.continue();\n\n                } else {\n                    resolve();\n                }\n            };\n\n            request.onerror = function (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function counts the number of records\n     * @returns {Promise}\n     */\n    Model.prototype.count = function count () {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = 0;\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        result++;\n                    }\n\n                    cursor.continue();\n\n                }else{\n                    resolve(result);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Function averages the numeric value at the given point\n     * @param attribute\n     * @returns {Promise}\n     */\n    Model.prototype.average = function average (attribute) {\n        var model = this;\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = 0, totalRecords = 0;\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        totalRecords++;\n                        var tempResult = Model.helpers.getNestedAttribute(attribute, cursor.value);\n                        tempResult = parseFloat(tempResult);\n                        tempResult = isNaN(tempResult) ? 0 : tempResult;\n                        result += tempResult;\n                    }\n\n                    cursor.continue();\n\n                }else{\n                    resolve(result/totalRecords);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Reduce function is called with each passing iterator value and reduced value is returned\n     * @param func\n     * @param defaultCarry\n     * @returns {Promise}\n     */\n    Model.prototype.reduce = function reduce (func, defaultCarry) {\n        var model = this;\n\n        if(typeof func !== 'function'){\n            throw \"Parameter should be a function type\";\n        }\n\n        return new Promise(function (resolve, reject) {\n            var transaction = model.getTransaction(model.tables, Model.READONLY);\n            var obj = transaction.objectStore(model.name);\n            var result = defaultCarry;\n            var request;\n\n            if(model.indexBuilder.type){\n                request = model.getIndexResult(obj);\n            }else{\n                request = obj.openCursor();\n            }\n\n            request.onsuccess = function (e) {\n                var cursor = e.target.result;\n\n                if(cursor){\n                    if(model.checkBuilderValue(cursor.value)){\n                        result = func(cursor.value, result);\n                    }\n\n                    cursor.continue();\n\n                }else{\n                    resolve(result);\n                }\n            };\n\n            request.onerror = function(e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Sets the index search criteria\n     * @param objectStore\n     * @returns {*}\n     */\n    Model.prototype.getIndexResult = function getIndexResult (objectStore) {\n        var builder = this;\n        var range;\n        var index;\n\n\n        if(!builder.indexBuilder.type) {\n            return objectStore.openCursor();\n        }\n\n        if(builder.indexBuilder.index !== builder.primary){\n            index = objectStore.index(builder.indexBuilder.index);\n        }else{\n            index = objectStore;\n        }\n\n        switch (builder.indexBuilder.type) {\n            case 'and' :\n                range = builder.idbKey.only(builder.indexBuilder.value);\n                break;\n\n            case 'in' :\n                builder.whereIn(builder.indexBuilder.index, builder.indexBuilder.value);\n                var values = builder.indexBuilder.value.sort();\n                range = builder.idbKey.bound(values[0], values[values.length - 1], false, false);\n                break;\n\n            case 'gte' :\n                range = builder.idbKey.lowerBound(builder.indexBuilder.value, false);\n                break;\n\n            case 'gt' :\n                range = builder.idbKey.lowerBound(builder.indexBuilder.value, true);\n                break;\n\n            case 'lte' :\n                range = builder.idbKey.upperBound(builder.indexBuilder.value, false);\n                break;\n\n            case 'lt' :\n                range = builder.idbKey.lowerBound(builder.indexBuilder.value, true);\n                break;\n\n            case 'between' :\n                range = builder.idbKey.bound(builder.indexBuilder.value[0], builder.indexBuilder.value[1], false, false);\n                break;\n            default :\n                throw 'Invalid builder type found';\n        }\n\n        return index.openCursor(range);\n    };\n\n    /**\n     * Checks common search criteria other than the index values\n     * @param value\n     * @returns {boolean}\n     */\n    Model.prototype.checkBuilderValue = function checkBuilderValue (value) {\n        var builder = this;\n        var result = true;\n        var i,j;\n        for (i = 0; i < builder.builder.length; i++){\n\n            var condition = builder.builder[i];\n            switch(condition.type){\n\n                case 'and' : //case for one to one search\n                    if(!Model.helpers.checkNestedAttribute(condition.attribute, value, condition.value)){\n                        return false;\n                    }\n                    break;\n\n                case 'in' : //case for list search\n                    var tempCheck = false;\n                    for(j = 0; j < condition.value.length; j++) {\n                        result = Model.helpers.checkNestedAttribute(condition.attribute, value, condition.value[j]);\n                        if(result !== undefined && result !== false) {\n                            tempCheck = true;\n                        }\n                    }\n\n                    if(!tempCheck){\n                        return false;\n                    }\n\n                    result = true;\n\n                    break;\n\n                case 'gte' : //case for checking the value is greater than or is equal to the same\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result < condition.value){\n                        return false;\n                    }\n\n                    result = true;\n                    break;\n\n                case 'gt' : //case for checking the value is greater than the same\n\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result <= condition.value){\n                        return false;\n                    }\n\n                    result = true;\n                    break;\n\n                case 'lte' : //case for checking the value is less than or is equal to the same\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result > condition.value){\n                        return false;\n                    }\n                    result = true;\n                    break;\n\n                case 'lt' : //case for checking the value is less than the same\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(result >= condition.value){\n                        return false;\n                    }\n                    result = true;\n                    break;\n\n                case 'between' : //case for checking the value is between the given range(ONLY WORKS FOR NUMERIC)\n                    result = Model.helpers.getNestedAttribute(condition.attribute, value);\n\n                    if(result === undefined) {\n                        return false;\n                    }\n\n                    if(condition.value[0] >= result && condition.value[1] <= result){\n                        return false\n                    }\n                    result = true;\n                    break;\n\n                default:\n                    result = true;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Creates a transaction\n     * @param tables\n     * @param mode\n     */\n    Model.prototype.createTransaction = function createTransaction (tables, mode) {\n        this.transaction = this.db.transaction(tables, mode)\n    };\n\n    /**\n     * Sets IDBTransaction obejct to current model scope\n     * @param transaction\n     */\n    Model.prototype.setTransaction = function setTransaction (transaction) {\n        this.transaction = transaction\n    };\n\n    /**\n     * Returns the IDBTransaction object set in current scope\n     * @param {Array} tables\n     * @param {String} mode\n     * @param {boolean} overwrite\n     * @returns {*|null}\n     */\n    Model.prototype.getTransaction = function getTransaction (tables, mode, overwrite) {\n        overwrite = overwrite === undefined ? false : overwrite;\n\n        if(!this.transaction || overwrite === true) {\n            this.createTransaction(tables, mode);\n        }\n\n        return this.transaction;\n    };\n\n    /**\n     * Returns the array or direct key value against the input give for the key specified\n     * @param result\n     * @param key\n     * @param isArray\n     * @returns {*}\n     */\n    Model.prototype.getMainResult = function getMainResult (result, key, isArray) {\n        if(isArray){\n            return result.map(function (item) {\n                return item[key];\n            });\n        }else{\n            return result[key];\n        }\n    };\n\n    /**\n     * Searches for relationships assigned with builder and fetches them\n     * @param relation\n     * @param transaction\n     * @param mainResult\n     * @param isArray\n     * @returns {Promise}\n     */\n    Model.prototype.getRelationships = function getRelationships (relation, transaction, mainResult, isArray) {\n\n        isArray = isArray || false;\n\n        var model = this;\n        var primary = relation.primary || 'id';\n\n        /**\n         * @var Model relationModel\n         */\n        var relationModel = new Model(model.db, model.idbKey, relation.modelName, relation.primary);\n\n        //setting the relation transaction same as parent transaction\n        relationModel.setTransaction(transaction);\n\n        //if a secondry builder function was defined\n        if(relation.func){\n            var tempBuilder = new Builder();\n\n            tempBuilder = relation.func(tempBuilder);\n\n            relationModel.tables = tempBuilder.tables;\n            relationModel.tables.push(relationModel.name);\n            relationModel.relations = tempBuilder.relations;\n            relationModel.builder = tempBuilder.builder;\n        }\n\n        //checking type of parent result\n        if(isArray){\n            relationModel.whereIndexIn(relation.foreignKey, mainResult);\n        }else{\n            relationModel.whereIndex(relation.foreignKey, mainResult);\n        }\n\n        return new Promise(function (relationResolve, relationReject) {\n\n            var result;\n\n            //if relation type mentioned\n            switch (relation.type) {\n                case Model.RELATIONS.hasOne :\n                    result = relationModel.first();\n                    break;\n                case Model.RELATIONS.hasMany :\n                    result = relationModel.get();\n                    break;\n                default :\n                    throw \"Invalid relation type provided\";\n            }\n\n            result.then(function (r) {\n                relationResolve(r);\n            }).catch(function (err) {\n                relationReject(err);\n            });\n\n        });\n    };\n\n    /**\n     * Gets the default value of result. Null for hasOne and array for hasMany\n     * @param type\n     * @returns {*}\n     */\n    Model.prototype.getDefaultRelationValue = function getDefaultRelationValue (type) {\n    switch (type) {\n        case Model.RELATIONS.hasOne :\n            return null;\n        case Model.RELATIONS.hasMany :\n            return [];\n        default :\n            return null;\n    }\n};\n\n\n    /**\n     * Readwrite parameter of indexedDB\n     * @return {string}\n     */\n    staticAccessors$1.READWRITE.get = function () {\n        return \"readwrite\";\n    };\n\n    /**\n     * Readonly parameter of indexedDB\n     * @return {string}\n     */\n    staticAccessors$1.READONLY.get = function () {\n        return \"readonly\";\n    };\n\n    Object.defineProperties( Model, staticAccessors$1 );\n\n    return Model;\n}(Builder));\n\nvar Migration = function Migration(db, transaction, migrations) {\n    /**\n     * @var IDBDatabase db\n     */\n    this.db = db;\n    this.migrations = migrations;\n    this.objectStores = [];\n\n    /**\n     * @var IDBTransaction transaction\n     */\n    this.transaction = transaction;\n};\n\nMigration.prototype.createStore = function createStore (schema) {\n    var mig = this;\n    var primary = schema.primary || 'id';\n\n    var objectStore = mig.db.createObjectStore(schema.name, {keyPath: primary, autoIncrement: true});\n    mig.objectStores.push(objectStore);\n\n    if (schema.columns) {\n        schema.columns.forEach(function (column) { return mig.makeIndex(column, objectStore); });\n    }\n\n\n};\n\nMigration.prototype.run = function run () {\n    var mig = this;\n\n    mig.migrations.forEach(function (schema) {\n        if(mig.db.objectStoreNames.contains(schema.name)){\n\n            if(schema.drop){\n                mig.db.deleteObjectStore(schema.name);\n            }else{\n                mig.updateStore(schema);\n            }\n\n\n        }else{\n            mig.createStore(schema);\n        }\n    });\n};\n\nMigration.prototype.makeIndex = function makeIndex (column, objectStore) {\n    column.attributes = column.attributes || {};\n    column.index = column.index || column.name;\n    objectStore.createIndex(column.name, column.index, column.attributes);\n};\n\nMigration.prototype.updateStore = function updateStore (schema) {\n    var mig = this;\n\n    var objectStore = mig.transaction.objectStore(schema.name);\n\n    if (schema.columns) {\n\n        schema.columns.forEach(function (column) {\n            if(!objectStore.indexNames.contains(column.name)){\n                mig.makeIndex(column, objectStore)\n            }\n        });\n    }\n\n    if(schema.dropColumns) {\n        schema.dropColumns.forEach(function (column) {\n            if(objectStore.indexNames.contains(column)){\n                mig.dropIndex(column, objectStore)\n            }\n        });\n    }\n};\n\nMigration.prototype.dropIndex = function dropIndex (columnName, objectStore) {\n    debugger;\n    objectStore.deleteIndex(columnName);\n};\n\n\n\nvar db, models;\nvar errorNamespace = '-error';\n\nself.addEventListener('message', function (e) {\n    \"use strict\";\n    JSON.parse(e.data.detail);\n    var data = JSON.parse(e.data.detail, function (key, value) {\n        if(typeof value != 'string'){\n            return value;\n        }\n        return ( value.indexOf('function') >= 0 || value.indexOf('=>') >= 0) ? eval('('+value+')') : value;\n    });\n    self.emit(data, e.data.timestamp, e.data.action, e.data.model);\n});\n\nself.addEventListener('idb:worker:initialize', function (e) {\n    \"use strict\";\n\n    var idb = self.indexedDB || self.mozIndexedDB || self.webkitIndexedDB || self.msIndexedDB;\n    var idbKey = self.IDBKeyRange || self.webkitIDBKeyRange || self.msIDBKeyRange;\n\n    db = new DB(idb, idbKey, e.detail.detail, false);\n\n    db.connect()\n        .then(function (m) {\n            models = m;\n            self.send(true, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (e) { return self.send(false, e.detail.timestamp, e.detail.action); });\n\n});\n\nself.emit = function (data, timestamp, action, model) {\n    var ev = new self.CustomEvent('idb:worker:' + action, {\n        detail: {\n            detail: data,\n            timestamp: timestamp,\n            action: action,\n            model: model\n        }\n    });\n\n    self.dispatchEvent(ev);\n};\n\nself.send = function (data, timestamp, action) {\n    \"use strict\";\n\n    var ev = {\n        detail: data,\n        action: action,\n        timestamp: timestamp,\n    };\n\n    self.postMessage(ev);\n};\n\n\nself.addEventListener('idb:worker:create', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.create(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:find', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n    m.builder = e.detail.detail.builder;\n    m.indexBuilder = e.detail.detail.indexBuilder;\n    m.tables = e.detail.detail.tables;\n    m.relations = e.detail.detail.relations;\n\n    m.find(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:createMultiple', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n    m.createMultiple(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:get', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n    m.builder = e.detail.detail.builder;\n    m.indexBuilder = e.detail.detail.indexBuilder;\n    m.tables = e.detail.detail.tables;\n    m.relations = e.detail.detail.relations;\n\n    m.get(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:first', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n    m.builder = e.detail.detail.builder;\n    m.indexBuilder = e.detail.detail.indexBuilder;\n    m.tables = e.detail.detail.tables;\n    m.relations = e.detail.detail.relations;\n\n    m.first(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (err) {\n            self.send(err, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:update', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.update(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:save', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.save(e.detail.detail.id, e.detail.detail.data)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:count', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.count()\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:average', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.average(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\n\nself.addEventListener('idb:worker:reduce', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.reduce(e.detail.detail.func, e.detail.detail.defaultCarry)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:destroyId', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.destroyId(e.detail.detail)\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n\nself.addEventListener('idb:worker:destroy', function (e) {\n    \"use strict\";\n\n    var m = models[e.detail.model];\n\n    m.destroy()\n        .then(function (result) {\n            self.send(result, e.detail.timestamp, e.detail.action);\n        })\n        .catch(function (er) {\n            self.send(er, e.detail.timestamp, e.detail.action + errorNamespace);\n        });\n});\n//# sourceMappingURL=worker.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9idWlsZC93b3JrZXIuanM/YmUwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBEQiB7XG5cbiAgICBjb25zdHJ1Y3RvcihpZGIsIGlkYktleSwgc2V0dGluZ3MsIHVzZVdlYldvcmtlciwgcGF0aFRvV2ViV29ya2VyKSB7XG4gICAgICAgIHRoaXMuZGIgPSBpZGI7XG4gICAgICAgIHRoaXMuaWRiS2V5ID0gaWRiS2V5O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMudXNlV2ViV29ya2VyID0gdXNlV2ViV29ya2VyIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmlzV2ViV29ya2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF0aFRvV2ViV29ya2VyID0gcGF0aFRvV2ViV29ya2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGRhdGFiYXNlIGNvbm5lY3Rpb24gd2l0aCBpbmRleGVkREJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGxldCBkYiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIGlmKGRiLnVzZVdlYldvcmtlcil7XG4gICAgICAgICAgICAgICAgZGIuY3JlYXRlV29ya2VySGFuZGxlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZGIuY3JlYXRlTm9ybWFsSGFuZGxlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cy9EZWxldGVzIHRoZSBkYXRhYmFhc2VcbiAgICAgKiBAcGFyYW0gZGJOYW1lXG4gICAgICovXG4gICAgZGVzdHJveShkYk5hbWUpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdkYXRhYmFzZSAnICsgZGJOYW1lICsgJyBkZWxldGVkJyk7XG4gICAgICAgIHRoaXMuZGIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNvbm5lY3Rpb24gaW4gd2ViIHdvcmtlciBzcGFjZSBhbmQgaWYgd2ViIHdvcmtlciBmYWlsc1xuICAgICAqIHRoZW4gY3JlYXRlcyBub3JtYWwgZGF0YWJhc2UgY29ubmVjdGlvbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSByZXNvbHZlXG4gICAgICogQHBhcmFtIHJlamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZVdvcmtlckhhbmRsZXIgKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsZXQgZGIgPSB0aGlzO1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBsZXQgd29ya2VyID0gbmV3IHdpbmRvdy5Xb3JrZXIoZGIucGF0aFRvV2ViV29ya2VyKTtcbiAgICAgICAgICAgIGxldCBtb2RlbHMgPSB7fTtcbiAgICAgICAgICAgIGxldCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGRldGFpbCA6IEpTT04uc3RyaW5naWZ5KGRiLnNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICBhY3Rpb24gOiAnaW5pdGlhbGl6ZScsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wIDogdGltZXN0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYoZS5kYXRhLmFjdGlvbiA9PT0gJ2luaXRpYWxpemUnICYmIGUuZGF0YS50aW1lc3RhbXAgPT09IHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLmRldGFpbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuc2V0dGluZ3MubWlncmF0aW9ucy5mb3JFYWNoKChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kZWxzLCBzY2hlbWEubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmtlck1vZGVsSGFuZGxlcihzY2hlbWEubmFtZSwgd29ya2VyLCB3aW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGIuaXNXZWJXb3JrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtb2RlbHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlTm9ybWFsSGFuZGxlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1jYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5vcm1hbCBkYXRhYmFzZSBpbnN0YW5jZSBhbmQgbW9kZWxzXG4gICAgICogQHBhcmFtIHJlc29sdmVcbiAgICAgKiBAcGFyYW0gcmVqZWN0XG4gICAgICovXG4gICAgY3JlYXRlTm9ybWFsSGFuZGxlciAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBkYiA9IHRoaXM7XG5cbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmRiLm9wZW4odGhpcy5zZXR0aW5ncy5kYk5hbWUsIHRoaXMuc2V0dGluZ3MuZGJWZXJzaW9uKTtcblxuICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBsZXQgbWlnID0gbmV3IE1pZ3JhdGlvbihlLnRhcmdldC5yZXN1bHQsIGUudGFyZ2V0LnRyYW5zYWN0aW9uLCBkYi5zZXR0aW5ncy5taWdyYXRpb25zKTtcbiAgICAgICAgICAgIG1pZy5ydW4oKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGxldCBtb2RlbHMgPSB7fTtcblxuICAgICAgICAgICAgZGIuc2V0dGluZ3MubWlncmF0aW9ucy5mb3JFYWNoKChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJpbWFyeSA9IHNjaGVtYS5wcmltYXJ5IHx8ICdpZCc7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZGVscywgc2NoZW1hLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2RlbChlLnRhcmdldC5yZXN1bHQsIGRiLmlkYktleSwgc2NoZW1hLm5hbWUsIHByaW1hcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzb2x2ZShtb2RlbHMpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIEJ1aWxkZXIge1xuXG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleEJ1aWxkZXIgPSB7fTtcbiAgICAgICAgdGhpcy5yZWxhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50YWJsZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmRleCBidWlsZGVyIHZhbHVlIGFzIGFuICdhbmQnIHJlZmVyZW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4TmFtZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFsdWUgbWl4ZWRcbiAgICAgKiBAcmV0dXJucyB7QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aGVyZUluZGV4KGluZGV4TmFtZSwgdmFsdWUpIHtcblxuICAgICAgICB0aGlzLmluZGV4QnVpbGRlciA9IHtcbiAgICAgICAgICAgIGluZGV4IDogaW5kZXhOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnYW5kJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluZGV4IGJ1aWxkZXIgdmFsdWUgYXMgYW4gJ2luJyByZWZlcmVuY2VcbiAgICAgKiBAcGFyYW0gaW5kZXhOYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge0J1aWxkZXJ9XG4gICAgICovXG4gICAgd2hlcmVJbmRleEluKGluZGV4TmFtZSwgdmFsdWUpIHtcblxuICAgICAgICB0aGlzLmluZGV4QnVpbGRlciA9IHtcbiAgICAgICAgICAgIGluZGV4IDogaW5kZXhOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnaW4nXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5kZXggYnVpbGRlciB2YWx1ZSB3aXRoIHBvaW50IGluY2x1c2l2ZSBhbmQgc2V0cyBncmVhdGVyIHRoYW4gY2hlY2tcbiAgICAgKiBAcGFyYW0gaW5kZXhOYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge0J1aWxkZXJ9XG4gICAgICovXG4gICAgaW5kZXhHdGUoaW5kZXhOYW1lLCB2YWx1ZSkge1xuXG4gICAgICAgIHRoaXMuaW5kZXhCdWlsZGVyID0ge1xuICAgICAgICAgICAgaW5kZXggOiBpbmRleE5hbWUsXG4gICAgICAgICAgICB2YWx1ZSA6IHZhbHVlLFxuICAgICAgICAgICAgdHlwZSA6ICdndGUnXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5kZXggYnVpbGRlciB2YWx1ZSB3aXRoIHBvaW50IG5vdCBpbmNsdXNpdmUgYW5kIHNldHMgZ3JlYXRlciB0aGFuIGNoZWNrXG4gICAgICogQHBhcmFtIGluZGV4TmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCdWlsZGVyfVxuICAgICAqL1xuICAgIGluZGV4R3QoaW5kZXhOYW1lLCB2YWx1ZSkge1xuXG4gICAgICAgIHRoaXMuaW5kZXhCdWlsZGVyID0ge1xuICAgICAgICAgICAgaW5kZXggOiBpbmRleE5hbWUsXG4gICAgICAgICAgICB2YWx1ZSA6IHZhbHVlLFxuICAgICAgICAgICAgdHlwZSA6ICdndCdcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmRleCBidWlsZGVyIHZhbHVlIHdpdGggcG9pbnQgaW5jbHVzaXZlIGFuZCBzZXRzIGxlc3MgdGhhbiBjaGVja1xuICAgICAqIEBwYXJhbSBpbmRleE5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QnVpbGRlcn1cbiAgICAgKi9cbiAgICBpbmRleEx0ZShpbmRleE5hbWUsIHZhbHVlKSB7XG5cbiAgICAgICAgdGhpcy5pbmRleEJ1aWxkZXIgPSB7XG4gICAgICAgICAgICBpbmRleCA6IGluZGV4TmFtZSxcbiAgICAgICAgICAgIHZhbHVlIDogdmFsdWUsXG4gICAgICAgICAgICB0eXBlIDogJ2x0ZSdcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmRleCBidWlsZGVyIHZhbHVlIHdpdGggcG9pbnQgbm90IGluY2x1c2l2ZSBhbmQgc2V0cyBsZXNzIHRoYW4gY2hlY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleE5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QnVpbGRlcn1cbiAgICAgKi9cbiAgICBpbmRleEx0KGluZGV4TmFtZSwgdmFsdWUpIHtcblxuICAgICAgICB0aGlzLmluZGV4QnVpbGRlciA9IHtcbiAgICAgICAgICAgIGluZGV4IDogaW5kZXhOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnbHQnXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5kZXggYnVpbGRlciB2YWx1ZSB3aXRoIHBvaW50cyBpbmNsdXNpdmUgYW5kIHNldHMgcmFuZ2UgYmV0d2VlbiB0aGVtXG4gICAgICogQHBhcmFtIGluZGV4TmFtZVxuICAgICAqIEBwYXJhbSBsb3dlclxuICAgICAqIEBwYXJhbSB1cHBlclxuICAgICAqIEByZXR1cm5zIHtCdWlsZGVyfVxuICAgICAqL1xuICAgIGluZGV4QmV0d2VlbihpbmRleE5hbWUsIGxvd2VyLCB1cHBlcikge1xuXG4gICAgICAgIHRoaXMuaW5kZXhCdWlsZGVyID0ge1xuICAgICAgICAgICAgaW5kZXggOiBpbmRleE5hbWUsXG4gICAgICAgICAgICB2YWx1ZSA6IFtsb3dlciwgdXBwZXJdLFxuICAgICAgICAgICAgdHlwZSA6ICdiZXR3ZWVuJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHdoZXJlSW4oYXR0cmlidXRlTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWlsZGVyLnB1c2goe1xuICAgICAgICAgICAgYXR0cmlidXRlIDogYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgIHZhbHVlIDogdmFsdWUsXG4gICAgICAgICAgICB0eXBlIDogJ2luJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB3aGVyZShhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnYW5kJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGd0ZShhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnZ3RlJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBndChhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnZ3QnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGx0ZShhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnbHRlJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsdChhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGUgOiAnbHQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGJldHdlZW4oYXR0cmlidXRlTmFtZSwgdXBwZXIsIGxvd2VyKSB7XG4gICAgICAgIHVwcHBlciA9IHBhcnNlRmxvYXQodXBwZXIpO1xuICAgICAgICBsb3dlciA9IHBhcnNlRmxvYXQobG93ZXIpO1xuXG4gICAgICAgIGlmKGlzTmFOKHVwcGVyKSB8fCBpc05hTihsb3dlcikpe1xuICAgICAgICAgICAgdGhyb3cgXCJCZXR3ZWVuIGlzIG9ubHkgZm9yIG51bWVyaWMgdmFsdWVzXCI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkZXIucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdmFsdWUgOiBbdXBwZXIsIGxvd2VyXSxcbiAgICAgICAgICAgIHR5cGUgOiAnYmV0d2VlbidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVsYXRpb24obW9kZWxOYW1lLCB0eXBlLCBsb2NhbEtleSwgZm9yZWlnbktleSwgZnVuYywgcHJpbWFyeSkge1xuICAgICAgICB0aGlzLnRhYmxlcy5wdXNoKG1vZGVsTmFtZSk7XG5cbiAgICAgICAgdGhpcy5yZWxhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBtb2RlbE5hbWUgOiBtb2RlbE5hbWUsXG4gICAgICAgICAgICBmdW5jIDogZnVuYyxcbiAgICAgICAgICAgIGxvY2FsS2V5IDogbG9jYWxLZXksXG4gICAgICAgICAgICBmb3JlaWduS2V5IDogZm9yZWlnbktleSxcbiAgICAgICAgICAgIHR5cGUgOiB0eXBlLFxuICAgICAgICAgICAgcHJpbWFyeSA6IHByaW1hcnlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBoZWxwZXJzKCkge1xuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIGNoZWNrTmVzdGVkQXR0cmlidXRlIChhdHRyaWJ1dGVTdHJpbmcsIHZhbHVlLCBjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uID09IE1vZGVsLmhlbHBlcnMuZ2V0TmVzdGVkQXR0cmlidXRlKGF0dHJpYnV0ZVN0cmluZywgdmFsdWUpXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXROZXN0ZWRBdHRyaWJ1dGUoYXR0cmlidXRlU3RyaW5nLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCBhdHRyaWJ1dGVzID0gYXR0cmlidXRlU3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY29udGVudFthdHRyaWJ1dGVzW2ldXSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudFthdHRyaWJ1dGVzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlcGxhY2VOZXN0ZWRWYWx1ZXMoYXR0cmlidXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGF0dHJpYnV0ZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2F0dHJpYnV0ZV0gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgUkVMQVRJT05TKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFzT25lIDogJ2hhc09uZScsXG4gICAgICAgICAgICBoYXNNYW55IDogJ2hhc01hbnknXG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBNb2RlbCBleHRlbmRzIEJ1aWxkZXJ7XG5cbiAgICBjb25zdHJ1Y3RvcihkYiwgaWRiS2V5LCBtb2RlbE5hbWUsIHByaW1hcnkpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9IG1vZGVsTmFtZTtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5O1xuICAgICAgICB0aGlzLnRhYmxlcyA9IFt0aGlzLm5hbWVdO1xuICAgICAgICB0aGlzLmlkYktleSA9IGlkYktleTtcbiAgICAgICAgdGhpcy5oYXNJZGJLZXkgPSB0aGlzLmlkYktleSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSByZXN1bHQgb24gdGhlIHByaW1hcnkga2V5IGRlZmluZWRcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmaW5kKGlkKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRE9OTFkpO1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBvYmouZ2V0KGlkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgZmlyc3QgdmFsdWUgaW4gZGF0YWJhc2UgYW5kIHJldHVybnMgdGhhdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZpcnN0KCkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb24gPSBtb2RlbC5nZXRUcmFuc2FjdGlvbihtb2RlbC50YWJsZXMsIE1vZGVsLlJFQURPTkxZKTtcbiAgICAgICAgICAgIGxldCBvYmogPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShtb2RlbC5uYW1lKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3Q7XG5cbiAgICAgICAgICAgIGlmKG1vZGVsLmluZGV4QnVpbGRlci50eXBlKXtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbW9kZWwuZ2V0SW5kZXhSZXN1bHQob2JqKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBvYmoub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmKGN1cnNvcil7XG4gICAgICAgICAgICAgICAgICAgIGlmKG1vZGVsLmNoZWNrQnVpbGRlclZhbHVlKGN1cnNvci52YWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlbGF0aW9uc0NvbXBsZXRlZCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnNvci52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobW9kZWwucmVsYXRpb25zLmxlbmd0aCA+IDAgJiYgKHJlc3VsdCAhPT0gbnVsbCB8fCByZXN1bHQgIT09IHVuZGVmaW5lZCkpe1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5yZWxhdGlvbnMuZm9yRWFjaCgocmVsYXRpb24pID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVsYXRpb25SZXF1ZXN0ID0gbW9kZWwuZ2V0UmVsYXRpb25zaGlwcyhyZWxhdGlvbiwgbW9kZWwudHJhbnNhY3Rpb24sIG1vZGVsLmdldE1haW5SZXN1bHQocmVzdWx0LCByZWxhdGlvbi5sb2NhbEtleSwgZmFsc2UpLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25SZXF1ZXN0LnRoZW4oKHJlbGF0aW9uUmVzdWx0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uc0NvbXBsZXRlZCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gbW9kZWwuZ2V0RGVmYXVsdFJlbGF0aW9uVmFsdWUocmVsYXRpb24udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVsYXRpb24ubW9kZWxOYW1lXSA9IHJlc3VsdFtyZWxhdGlvbi5tb2RlbE5hbWVdIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZWxhdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlbC5SRUxBVElPTlMuaGFzT25lIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZWxhdGlvbi5tb2RlbE5hbWVdID0gcmVsYXRpb25SZXN1bHRbcmVsYXRpb24uZm9yZWlnbktleV0gPT0gcmVzdWx0W3JlbGF0aW9uLmxvY2FsS2V5XSA/IHJlbGF0aW9uUmVzdWx0IDogcmVzdWx0W3JlbGF0aW9uLm1vZGVsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVsLlJFTEFUSU9OUy5oYXNNYW55IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uUmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZWxhdGlvbi5tb2RlbE5hbWVdID0gcmVsYXRpb25SZXN1bHQuZmlsdGVyKChyZWxhdGlvblJlc3VsdEl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVsYXRpb25SZXN1bHRJdGVtW3JlbGF0aW9uLmZvcmVpZ25LZXldID09IHJlc3VsdFtyZWxhdGlvbi5sb2NhbEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uc0NvbXBsZXRlZCA9PSBtb2RlbC5yZWxhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gc2VhcmNoZXMgdGhyb3VnaG91dCB0aGUgZGF0YWJhc2UgYW5kIHJldHVybnMgYSBhcnJheSBvZiByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRE9OTFkpO1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3Q7XG5cbiAgICAgICAgICAgIGlmKG1vZGVsLmluZGV4QnVpbGRlci50eXBlKXtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbW9kZWwuZ2V0SW5kZXhSZXN1bHQob2JqKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBvYmoub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmKGN1cnNvcil7XG4gICAgICAgICAgICAgICAgICAgIGlmKG1vZGVsLmNoZWNrQnVpbGRlclZhbHVlKGN1cnNvci52YWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcblxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFpblJlc3VsdCwgcmVsYXRpb25zQ29tcGxldGVkID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZihtb2RlbC5yZWxhdGlvbnMubGVuZ3RoID4gMCAmJiByZXN1bHQubGVuZ3RoID4gMCl7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwucmVsYXRpb25zLmZvckVhY2goKHJlbGF0aW9uKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVsYXRpb25SZXF1ZXN0ID0gbW9kZWwuZ2V0UmVsYXRpb25zaGlwcyhyZWxhdGlvbiwgbW9kZWwudHJhbnNhY3Rpb24sIG1vZGVsLmdldE1haW5SZXN1bHQocmVzdWx0LCByZWxhdGlvbi5sb2NhbEtleSwgdHJ1ZSksIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25SZXF1ZXN0LnRoZW4oKHJlbGF0aW9uUmVzdWx0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zQ29tcGxldGVkKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChpdGVtID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlZmF1bHRWYWx1ZSA9IG1vZGVsLmdldERlZmF1bHRSZWxhdGlvblZhbHVlKHJlbGF0aW9uLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtyZWxhdGlvbi5tb2RlbE5hbWVdID0gaXRlbVtyZWxhdGlvbi5tb2RlbE5hbWVdIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZWxhdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlbC5SRUxBVElPTlMuaGFzT25lIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVsYXRpb25SZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtyZWxhdGlvbi5tb2RlbE5hbWVdID0gcmVsYXRpb25SZXN1bHRbcmVsYXRpb24uZm9yZWlnbktleV0gPT0gaXRlbVtyZWxhdGlvbi5sb2NhbEtleV0gPyByZWxhdGlvblJlc3VsdCA6IGl0ZW1bcmVsYXRpb24ubW9kZWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZWwuUkVMQVRJT05TLmhhc01hbnkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZWxhdGlvblJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtW3JlbGF0aW9uLm1vZGVsTmFtZV0gPSByZWxhdGlvblJlc3VsdC5maWx0ZXIoKHJlbGF0aW9uUmVzdWx0SXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWxhdGlvblJlc3VsdEl0ZW1bcmVsYXRpb24uZm9yZWlnbktleV0gPT0gaXRlbVtyZWxhdGlvbi5sb2NhbEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlbGF0aW9uc0NvbXBsZXRlZCA9PSBtb2RlbC5yZWxhdGlvbnMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gY3JlYXRlcyBhIHNpbmdsZSByZWNvcmRcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGNyZWF0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRFdSSVRFKTtcblxuICAgICAgICAgICAgbGV0IG9iaiA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG1vZGVsLm5hbWUpO1xuXG4gICAgICAgICAgICBkYXRhLmNyZWF0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBkYXRhLnVwZGF0ZWRBdCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gb2JqLmFkZChkYXRhKTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGRhdGFbbW9kZWwucHJpbWFyeV0gPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjcmVhdGVzIGxpc3Qgb2YgcmVjb3JkcyBwYXNzZWRcbiAgICAgKiBAcGFyYW0gZGF0YVJlY29yZHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBjcmVhdGVNdWx0aXBsZSAoZGF0YVJlY29yZHMpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbW9kZWwuZ2V0VHJhbnNhY3Rpb24obW9kZWwudGFibGVzLCBNb2RlbC5SRUFEV1JJVEUpO1xuXG4gICAgICAgICAgICBsZXQgb2JqID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUobW9kZWwubmFtZSk7XG4gICAgICAgICAgICBsZXQgY3JlYXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBkYXRhUmVjb3Jkcy5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0YS5jcmVhdGVkQXQgPSBjcmVhdGVkQXQ7XG4gICAgICAgICAgICAgICAgZGF0YS51cGRhdGVkQXQgPSB1cGRhdGVkQXQ7XG5cbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdCA9IG9iai5hZGQoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbbW9kZWwucHJpbWFyeV0gPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0Lmxlbmd0aCA9PT0gZGF0YVJlY29yZHMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1cGRhdGVzIHRoZSB2YXJpb3VzIHJlY29yZHMgd2l0aCBtYXRjaGluZyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHVwZGF0ZShkYXRhKSB7XG5cbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcztcbiAgICAgICAgbGV0IHVwZGF0ZWRBdCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRFdSSVRFKTtcbiAgICAgICAgICAgIGxldCBvYmogPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShtb2RlbC5uYW1lKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0LCB0b3RhbFJlY29yZHNCZWluZ1VwZGF0ZWQgPSAwLCB0b3RhbFJlY29yZHNVcGRhdGVkID0gMDtcblxuICAgICAgICAgICAgaWYobW9kZWwuaW5kZXhCdWlsZGVyLnR5cGUpe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBtb2RlbC5nZXRJbmRleFJlc3VsdChvYmopO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG9iai5vcGVuQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYoY3Vyc29yKXtcbiAgICAgICAgICAgICAgICAgICAgaWYobW9kZWwuY2hlY2tCdWlsZGVyVmFsdWUoY3Vyc29yLnZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFJlY29yZHNCZWluZ1VwZGF0ZWQrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gY3Vyc29yLnZhbHVlW21vZGVsLnByaW1hcnldO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNyZWF0ZWRBdCA9IGN1cnNvci52YWx1ZS5jcmVhdGVkQXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBNb2RlbC5oZWxwZXJzLnJlcGxhY2VOZXN0ZWRWYWx1ZXMoZGF0YSwgY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFttb2RlbC5wcmltYXJ5XSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC51cGRhdGVkQXQgPSB1cGRhdGVkQXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVSZXF1ZXN0ID0gY3Vyc29yLnVwZGF0ZShyZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmVjb3Jkc1VwZGF0ZWQrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRvdGFsUmVjb3Jkc1VwZGF0ZWQgPT09IHRvdGFsUmVjb3Jkc0JlaW5nVXBkYXRlZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcblxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXBkYXRlcyB0aGUgcmVjb3JkIGF0IHRoZSBnaXZlbiBpZFxuICAgICAqIEBwYXJhbSBpZFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgc2F2ZShpZCwgZGF0YSkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzO1xuICAgICAgICBsZXQgdXBkYXRlZEF0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICBtb2RlbC5maW5kKGlkKS50aGVuKChyZXN1bHQpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmKCFyZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoJ05vIHJlY29yZCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRFdSSVRFLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgb2JqID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUobW9kZWwubmFtZSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgaWQgPSByZXN1bHRbbW9kZWwucHJpbWFyeV07XG4gICAgICAgICAgICAgICAgbGV0IGNyZWF0ZWRBdCA9IHJlc3VsdC5jcmVhdGVkQXQ7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBNb2RlbC5oZWxwZXJzLnJlcGxhY2VOZXN0ZWRWYWx1ZXMoZGF0YSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRbbW9kZWwucHJpbWFyeV0gPSBpZDtcbiAgICAgICAgICAgICAgICByZXN1bHQuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cGRhdGVkQXQgPSB1cGRhdGVkQXQ7XG5cbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdCA9IG9iai5wdXQocmVzdWx0KTtcblxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBkZWxldGVzIHRoZSBlbnRyaWVzIGF0IHRoZSBnaXZlbiBwb2ludFxuICAgICAqIEBwYXJhbSBpZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGRlc3Ryb3lJZChpZCkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzO1xuXG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1vZGVsLmZpbmQoaWQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYoIXJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgncmVzdWx0IGF0IGlkIGRvZXMgbm90IGV4aXN0cycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRFdSSVRFLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgb2JqID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUobW9kZWwubmFtZSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBvYmouZGVsZXRlKGlkKTtcblxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGRlbGV0ZXMgdGhlIGVudHJpZXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb24gPSBtb2RlbC5nZXRUcmFuc2FjdGlvbihtb2RlbC50YWJsZXMsIE1vZGVsLlJFQURXUklURSk7XG4gICAgICAgICAgICBsZXQgb2JqID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUobW9kZWwubmFtZSk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCwgdG90YWxSZWNvcmRzQmVpbmdEZWxldGVkID0gMCwgdG90YWxSZWNvcmRzRGVsZXRlZCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChtb2RlbC5pbmRleEJ1aWxkZXIudHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBtb2RlbC5nZXRJbmRleFJlc3VsdChvYmopO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gb2JqLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5jaGVja0J1aWxkZXJWYWx1ZShjdXJzb3IudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFJlY29yZHNCZWluZ0RlbGV0ZWQrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGV0ZVJlcXVlc3QgPSBjdXJzb3IuZGVsZXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmVjb3Jkc0RlbGV0ZWQrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbFJlY29yZHNEZWxldGVkID09PSB0b3RhbFJlY29yZHNCZWluZ0RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gY291bnRzIHRoZSBudW1iZXIgb2YgcmVjb3Jkc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGNvdW50KCkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb24gPSBtb2RlbC5nZXRUcmFuc2FjdGlvbihtb2RlbC50YWJsZXMsIE1vZGVsLlJFQURPTkxZKTtcbiAgICAgICAgICAgIGxldCBvYmogPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShtb2RlbC5uYW1lKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3Q7XG5cbiAgICAgICAgICAgIGlmKG1vZGVsLmluZGV4QnVpbGRlci50eXBlKXtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbW9kZWwuZ2V0SW5kZXhSZXN1bHQob2JqKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBvYmoub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmKGN1cnNvcil7XG4gICAgICAgICAgICAgICAgICAgIGlmKG1vZGVsLmNoZWNrQnVpbGRlclZhbHVlKGN1cnNvci52YWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcblxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gYXZlcmFnZXMgdGhlIG51bWVyaWMgdmFsdWUgYXQgdGhlIGdpdmVuIHBvaW50XG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGF2ZXJhZ2UgKGF0dHJpYnV0ZSkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb24gPSBtb2RlbC5nZXRUcmFuc2FjdGlvbihtb2RlbC50YWJsZXMsIE1vZGVsLlJFQURPTkxZKTtcbiAgICAgICAgICAgIGxldCBvYmogPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShtb2RlbC5uYW1lKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwLCB0b3RhbFJlY29yZHMgPSAwO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3Q7XG5cbiAgICAgICAgICAgIGlmKG1vZGVsLmluZGV4QnVpbGRlci50eXBlKXtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbW9kZWwuZ2V0SW5kZXhSZXN1bHQob2JqKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBvYmoub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmKGN1cnNvcil7XG4gICAgICAgICAgICAgICAgICAgIGlmKG1vZGVsLmNoZWNrQnVpbGRlclZhbHVlKGN1cnNvci52YWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxSZWNvcmRzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcFJlc3VsdCA9IE1vZGVsLmhlbHBlcnMuZ2V0TmVzdGVkQXR0cmlidXRlKGF0dHJpYnV0ZSwgY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSZXN1bHQgPSBwYXJzZUZsb2F0KHRlbXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFJlc3VsdCA9IGlzTmFOKHRlbXBSZXN1bHQpID8gMCA6IHRlbXBSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGVtcFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0L3RvdGFsUmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkdWNlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGVhY2ggcGFzc2luZyBpdGVyYXRvciB2YWx1ZSBhbmQgcmVkdWNlZCB2YWx1ZSBpcyByZXR1cm5lZFxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICogQHBhcmFtIGRlZmF1bHRDYXJyeVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHJlZHVjZSAoZnVuYywgZGVmYXVsdENhcnJ5KSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXM7XG5cbiAgICAgICAgaWYodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpe1xuICAgICAgICAgICAgdGhyb3cgXCJQYXJhbWV0ZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24gdHlwZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG1vZGVsLmdldFRyYW5zYWN0aW9uKG1vZGVsLnRhYmxlcywgTW9kZWwuUkVBRE9OTFkpO1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGRlZmF1bHRDYXJyeTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0O1xuXG4gICAgICAgICAgICBpZihtb2RlbC5pbmRleEJ1aWxkZXIudHlwZSl7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG1vZGVsLmdldEluZGV4UmVzdWx0KG9iaik7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gb2JqLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICBpZihjdXJzb3Ipe1xuICAgICAgICAgICAgICAgICAgICBpZihtb2RlbC5jaGVja0J1aWxkZXJWYWx1ZShjdXJzb3IudmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoY3Vyc29yLnZhbHVlLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG5cbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluZGV4IHNlYXJjaCBjcml0ZXJpYVxuICAgICAqIEBwYXJhbSBvYmplY3RTdG9yZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldEluZGV4UmVzdWx0KG9iamVjdFN0b3JlKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gdGhpcztcbiAgICAgICAgbGV0IHJhbmdlO1xuICAgICAgICBsZXQgaW5kZXg7XG5cblxuICAgICAgICBpZighYnVpbGRlci5pbmRleEJ1aWxkZXIudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGJ1aWxkZXIuaW5kZXhCdWlsZGVyLmluZGV4ICE9PSBidWlsZGVyLnByaW1hcnkpe1xuICAgICAgICAgICAgaW5kZXggPSBvYmplY3RTdG9yZS5pbmRleChidWlsZGVyLmluZGV4QnVpbGRlci5pbmRleCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgaW5kZXggPSBvYmplY3RTdG9yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoYnVpbGRlci5pbmRleEJ1aWxkZXIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYW5kJyA6XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBidWlsZGVyLmlkYktleS5vbmx5KGJ1aWxkZXIuaW5kZXhCdWlsZGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnaW4nIDpcbiAgICAgICAgICAgICAgICBidWlsZGVyLndoZXJlSW4oYnVpbGRlci5pbmRleEJ1aWxkZXIuaW5kZXgsIGJ1aWxkZXIuaW5kZXhCdWlsZGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gYnVpbGRlci5pbmRleEJ1aWxkZXIudmFsdWUuc29ydCgpO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gYnVpbGRlci5pZGJLZXkuYm91bmQodmFsdWVzWzBdLCB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdndGUnIDpcbiAgICAgICAgICAgICAgICByYW5nZSA9IGJ1aWxkZXIuaWRiS2V5Lmxvd2VyQm91bmQoYnVpbGRlci5pbmRleEJ1aWxkZXIudmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZ3QnIDpcbiAgICAgICAgICAgICAgICByYW5nZSA9IGJ1aWxkZXIuaWRiS2V5Lmxvd2VyQm91bmQoYnVpbGRlci5pbmRleEJ1aWxkZXIudmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdsdGUnIDpcbiAgICAgICAgICAgICAgICByYW5nZSA9IGJ1aWxkZXIuaWRiS2V5LnVwcGVyQm91bmQoYnVpbGRlci5pbmRleEJ1aWxkZXIudmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbHQnIDpcbiAgICAgICAgICAgICAgICByYW5nZSA9IGJ1aWxkZXIuaWRiS2V5Lmxvd2VyQm91bmQoYnVpbGRlci5pbmRleEJ1aWxkZXIudmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdiZXR3ZWVuJyA6XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBidWlsZGVyLmlkYktleS5ib3VuZChidWlsZGVyLmluZGV4QnVpbGRlci52YWx1ZVswXSwgYnVpbGRlci5pbmRleEJ1aWxkZXIudmFsdWVbMV0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBidWlsZGVyIHR5cGUgZm91bmQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4Lm9wZW5DdXJzb3IocmFuZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBjb21tb24gc2VhcmNoIGNyaXRlcmlhIG90aGVyIHRoYW4gdGhlIGluZGV4IHZhbHVlc1xuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNoZWNrQnVpbGRlclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGxldCBpLGo7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBidWlsZGVyLmJ1aWxkZXIubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gYnVpbGRlci5idWlsZGVyW2ldO1xuICAgICAgICAgICAgc3dpdGNoKGNvbmRpdGlvbi50eXBlKXtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2FuZCcgOiAvL2Nhc2UgZm9yIG9uZSB0byBvbmUgc2VhcmNoXG4gICAgICAgICAgICAgICAgICAgIGlmKCFNb2RlbC5oZWxwZXJzLmNoZWNrTmVzdGVkQXR0cmlidXRlKGNvbmRpdGlvbi5hdHRyaWJ1dGUsIHZhbHVlLCBjb25kaXRpb24udmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2luJyA6IC8vY2FzZSBmb3IgbGlzdCBzZWFyY2hcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBDaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCBjb25kaXRpb24udmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1vZGVsLmhlbHBlcnMuY2hlY2tOZXN0ZWRBdHRyaWJ1dGUoY29uZGl0aW9uLmF0dHJpYnV0ZSwgdmFsdWUsIGNvbmRpdGlvbi52YWx1ZVtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcENoZWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0ZW1wQ2hlY2spe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2d0ZScgOiAvL2Nhc2UgZm9yIGNoZWNraW5nIHRoZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgaXMgZXF1YWwgdG8gdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gTW9kZWwuaGVscGVycy5nZXROZXN0ZWRBdHRyaWJ1dGUoY29uZGl0aW9uLmF0dHJpYnV0ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPCBjb25kaXRpb24udmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdndCcgOiAvL2Nhc2UgZm9yIGNoZWNraW5nIHRoZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNhbWVcblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBNb2RlbC5oZWxwZXJzLmdldE5lc3RlZEF0dHJpYnV0ZShjb25kaXRpb24uYXR0cmlidXRlLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA8PSBjb25kaXRpb24udmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdsdGUnIDogLy9jYXNlIGZvciBjaGVja2luZyB0aGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGlzIGVxdWFsIHRvIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1vZGVsLmhlbHBlcnMuZ2V0TmVzdGVkQXR0cmlidXRlKGNvbmRpdGlvbi5hdHRyaWJ1dGUsIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID4gY29uZGl0aW9uLnZhbHVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2x0JyA6IC8vY2FzZSBmb3IgY2hlY2tpbmcgdGhlIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBNb2RlbC5oZWxwZXJzLmdldE5lc3RlZEF0dHJpYnV0ZShjb25kaXRpb24uYXR0cmlidXRlLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA+PSBjb25kaXRpb24udmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYmV0d2VlbicgOiAvL2Nhc2UgZm9yIGNoZWNraW5nIHRoZSB2YWx1ZSBpcyBiZXR3ZWVuIHRoZSBnaXZlbiByYW5nZShPTkxZIFdPUktTIEZPUiBOVU1FUklDKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBNb2RlbC5oZWxwZXJzLmdldE5lc3RlZEF0dHJpYnV0ZShjb25kaXRpb24uYXR0cmlidXRlLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbmRpdGlvbi52YWx1ZVswXSA+PSByZXN1bHQgJiYgY29uZGl0aW9uLnZhbHVlWzFdIDw9IHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB0YWJsZXNcbiAgICAgKiBAcGFyYW0gbW9kZVxuICAgICAqL1xuICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHRhYmxlcywgbW9kZSkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbih0YWJsZXMsIG1vZGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBJREJUcmFuc2FjdGlvbiBvYmVqY3QgdG8gY3VycmVudCBtb2RlbCBzY29wZVxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHNldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEQlRyYW5zYWN0aW9uIG9iamVjdCBzZXQgaW4gY3VycmVudCBzY29wZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRhYmxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvdmVyd3JpdGVcbiAgICAgKiBAcmV0dXJucyB7KnxudWxsfVxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uKHRhYmxlcywgbW9kZSwgb3ZlcndyaXRlKSB7XG4gICAgICAgIG92ZXJ3cml0ZSA9IG92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvdmVyd3JpdGU7XG5cbiAgICAgICAgaWYoIXRoaXMudHJhbnNhY3Rpb24gfHwgb3ZlcndyaXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRyYW5zYWN0aW9uKHRhYmxlcywgbW9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvciBkaXJlY3Qga2V5IHZhbHVlIGFnYWluc3QgdGhlIGlucHV0IGdpdmUgZm9yIHRoZSBrZXkgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHJlc3VsdFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gaXNBcnJheVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldE1haW5SZXN1bHQgKHJlc3VsdCwga2V5LCBpc0FycmF5KSB7XG4gICAgICAgIGlmKGlzQXJyYXkpe1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIHJlbGF0aW9uc2hpcHMgYXNzaWduZWQgd2l0aCBidWlsZGVyIGFuZCBmZXRjaGVzIHRoZW1cbiAgICAgKiBAcGFyYW0gcmVsYXRpb25cbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gbWFpblJlc3VsdFxuICAgICAqIEBwYXJhbSBpc0FycmF5XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgZ2V0UmVsYXRpb25zaGlwcyAocmVsYXRpb24sIHRyYW5zYWN0aW9uLCBtYWluUmVzdWx0LCBpc0FycmF5KSB7XG5cbiAgICAgICAgaXNBcnJheSA9IGlzQXJyYXkgfHwgZmFsc2U7XG5cbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcztcbiAgICAgICAgbGV0IHByaW1hcnkgPSByZWxhdGlvbi5wcmltYXJ5IHx8ICdpZCc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB2YXIgTW9kZWwgcmVsYXRpb25Nb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHJlbGF0aW9uTW9kZWwgPSBuZXcgTW9kZWwobW9kZWwuZGIsIG1vZGVsLmlkYktleSwgcmVsYXRpb24ubW9kZWxOYW1lLCByZWxhdGlvbi5wcmltYXJ5KTtcblxuICAgICAgICAvL3NldHRpbmcgdGhlIHJlbGF0aW9uIHRyYW5zYWN0aW9uIHNhbWUgYXMgcGFyZW50IHRyYW5zYWN0aW9uXG4gICAgICAgIHJlbGF0aW9uTW9kZWwuc2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuXG4gICAgICAgIC8vaWYgYSBzZWNvbmRyeSBidWlsZGVyIGZ1bmN0aW9uIHdhcyBkZWZpbmVkXG4gICAgICAgIGlmKHJlbGF0aW9uLmZ1bmMpe1xuICAgICAgICAgICAgbGV0IHRlbXBCdWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcblxuICAgICAgICAgICAgdGVtcEJ1aWxkZXIgPSByZWxhdGlvbi5mdW5jKHRlbXBCdWlsZGVyKTtcblxuICAgICAgICAgICAgcmVsYXRpb25Nb2RlbC50YWJsZXMgPSB0ZW1wQnVpbGRlci50YWJsZXM7XG4gICAgICAgICAgICByZWxhdGlvbk1vZGVsLnRhYmxlcy5wdXNoKHJlbGF0aW9uTW9kZWwubmFtZSk7XG4gICAgICAgICAgICByZWxhdGlvbk1vZGVsLnJlbGF0aW9ucyA9IHRlbXBCdWlsZGVyLnJlbGF0aW9ucztcbiAgICAgICAgICAgIHJlbGF0aW9uTW9kZWwuYnVpbGRlciA9IHRlbXBCdWlsZGVyLmJ1aWxkZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNraW5nIHR5cGUgb2YgcGFyZW50IHJlc3VsdFxuICAgICAgICBpZihpc0FycmF5KXtcbiAgICAgICAgICAgIHJlbGF0aW9uTW9kZWwud2hlcmVJbmRleEluKHJlbGF0aW9uLmZvcmVpZ25LZXksIG1haW5SZXN1bHQpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJlbGF0aW9uTW9kZWwud2hlcmVJbmRleChyZWxhdGlvbi5mb3JlaWduS2V5LCBtYWluUmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVsYXRpb25SZXNvbHZlLCByZWxhdGlvblJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgICAvL2lmIHJlbGF0aW9uIHR5cGUgbWVudGlvbmVkXG4gICAgICAgICAgICBzd2l0Y2ggKHJlbGF0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGVsLlJFTEFUSU9OUy5oYXNPbmUgOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWxhdGlvbk1vZGVsLmZpcnN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZWwuUkVMQVRJT05TLmhhc01hbnkgOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWxhdGlvbk1vZGVsLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHJlbGF0aW9uIHR5cGUgcHJvdmlkZWRcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnRoZW4ociA9PiB7XG4gICAgICAgICAgICAgICAgcmVsYXRpb25SZXNvbHZlKHIpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICByZWxhdGlvblJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSBvZiByZXN1bHQuIE51bGwgZm9yIGhhc09uZSBhbmQgYXJyYXkgZm9yIGhhc01hbnlcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldERlZmF1bHRSZWxhdGlvblZhbHVlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBNb2RlbC5SRUxBVElPTlMuaGFzT25lIDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIE1vZGVsLlJFTEFUSU9OUy5oYXNNYW55IDpcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cblxuICAgIC8qKlxuICAgICAqIFJlYWR3cml0ZSBwYXJhbWV0ZXIgb2YgaW5kZXhlZERCXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUkVBRFdSSVRFKCkge1xuICAgICAgICByZXR1cm4gXCJyZWFkd3JpdGVcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkb25seSBwYXJhbWV0ZXIgb2YgaW5kZXhlZERCXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUkVBRE9OTFkoKSB7XG4gICAgICAgIHJldHVybiBcInJlYWRvbmx5XCI7XG4gICAgfVxuXG59XG5cbmNsYXNzIE1pZ3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZGIsIHRyYW5zYWN0aW9uLCBtaWdyYXRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdmFyIElEQkRhdGFiYXNlIGRiXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMubWlncmF0aW9ucyA9IG1pZ3JhdGlvbnM7XG4gICAgICAgIHRoaXMub2JqZWN0U3RvcmVzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB2YXIgSURCVHJhbnNhY3Rpb24gdHJhbnNhY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICB9XG5cbiAgICBjcmVhdGVTdG9yZShzY2hlbWEpIHtcbiAgICAgICAgbGV0IG1pZyA9IHRoaXM7XG4gICAgICAgIGxldCBwcmltYXJ5ID0gc2NoZW1hLnByaW1hcnkgfHwgJ2lkJztcblxuICAgICAgICBsZXQgb2JqZWN0U3RvcmUgPSBtaWcuZGIuY3JlYXRlT2JqZWN0U3RvcmUoc2NoZW1hLm5hbWUsIHtrZXlQYXRoOiBwcmltYXJ5LCBhdXRvSW5jcmVtZW50OiB0cnVlfSk7XG4gICAgICAgIG1pZy5vYmplY3RTdG9yZXMucHVzaChvYmplY3RTdG9yZSk7XG5cbiAgICAgICAgaWYgKHNjaGVtYS5jb2x1bW5zKSB7XG4gICAgICAgICAgICBzY2hlbWEuY29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IG1pZy5tYWtlSW5kZXgoY29sdW1uLCBvYmplY3RTdG9yZSkpO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIHJ1bigpIHtcbiAgICAgICAgbGV0IG1pZyA9IHRoaXM7XG5cbiAgICAgICAgbWlnLm1pZ3JhdGlvbnMuZm9yRWFjaCgoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBpZihtaWcuZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhzY2hlbWEubmFtZSkpe1xuXG4gICAgICAgICAgICAgICAgaWYoc2NoZW1hLmRyb3Ape1xuICAgICAgICAgICAgICAgICAgICBtaWcuZGIuZGVsZXRlT2JqZWN0U3RvcmUoc2NoZW1hLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBtaWcudXBkYXRlU3RvcmUoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgbWlnLmNyZWF0ZVN0b3JlKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1ha2VJbmRleChjb2x1bW4sIG9iamVjdFN0b3JlKSB7XG4gICAgICAgIGNvbHVtbi5hdHRyaWJ1dGVzID0gY29sdW1uLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICAgIGNvbHVtbi5pbmRleCA9IGNvbHVtbi5pbmRleCB8fCBjb2x1bW4ubmFtZTtcbiAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoY29sdW1uLm5hbWUsIGNvbHVtbi5pbmRleCwgY29sdW1uLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIHVwZGF0ZVN0b3JlKHNjaGVtYSkge1xuICAgICAgICBsZXQgbWlnID0gdGhpcztcblxuICAgICAgICBsZXQgb2JqZWN0U3RvcmUgPSBtaWcudHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2NoZW1hLm5hbWUpO1xuXG4gICAgICAgIGlmIChzY2hlbWEuY29sdW1ucykge1xuXG4gICAgICAgICAgICBzY2hlbWEuY29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZighb2JqZWN0U3RvcmUuaW5kZXhOYW1lcy5jb250YWlucyhjb2x1bW4ubmFtZSkpe1xuICAgICAgICAgICAgICAgICAgICBtaWcubWFrZUluZGV4KGNvbHVtbiwgb2JqZWN0U3RvcmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihzY2hlbWEuZHJvcENvbHVtbnMpIHtcbiAgICAgICAgICAgIHNjaGVtYS5kcm9wQ29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZihvYmplY3RTdG9yZS5pbmRleE5hbWVzLmNvbnRhaW5zKGNvbHVtbikpe1xuICAgICAgICAgICAgICAgICAgICBtaWcuZHJvcEluZGV4KGNvbHVtbiwgb2JqZWN0U3RvcmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcm9wSW5kZXgoY29sdW1uTmFtZSwgb2JqZWN0U3RvcmUpIHtcbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIG9iamVjdFN0b3JlLmRlbGV0ZUluZGV4KGNvbHVtbk5hbWUpO1xuICAgIH1cblxufVxuXG5cblxubGV0IGRiLCBtb2RlbHM7XG5sZXQgZXJyb3JOYW1lc3BhY2UgPSAnLWVycm9yJztcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGUpID0+IHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBKU09OLnBhcnNlKGUuZGF0YS5kZXRhaWwpO1xuICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShlLmRhdGEuZGV0YWlsLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZih0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoIHZhbHVlLmluZGV4T2YoJ2Z1bmN0aW9uJykgPj0gMCB8fCB2YWx1ZS5pbmRleE9mKCc9PicpID49IDApID8gZXZhbCgnKCcrdmFsdWUrJyknKSA6IHZhbHVlO1xuICAgIH0pO1xuICAgIHNlbGYuZW1pdChkYXRhLCBlLmRhdGEudGltZXN0YW1wLCBlLmRhdGEuYWN0aW9uLCBlLmRhdGEubW9kZWwpO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjppbml0aWFsaXplJywgKGUpID0+IHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGxldCBpZGIgPSBzZWxmLmluZGV4ZWREQiB8fCBzZWxmLm1vekluZGV4ZWREQiB8fCBzZWxmLndlYmtpdEluZGV4ZWREQiB8fCBzZWxmLm1zSW5kZXhlZERCO1xuICAgIGxldCBpZGJLZXkgPSBzZWxmLklEQktleVJhbmdlIHx8IHNlbGYud2Via2l0SURCS2V5UmFuZ2UgfHwgc2VsZi5tc0lEQktleVJhbmdlO1xuXG4gICAgZGIgPSBuZXcgREIoaWRiLCBpZGJLZXksIGUuZGV0YWlsLmRldGFpbCwgZmFsc2UpO1xuXG4gICAgZGIuY29ubmVjdCgpXG4gICAgICAgIC50aGVuKChtKSA9PiB7XG4gICAgICAgICAgICBtb2RlbHMgPSBtO1xuICAgICAgICAgICAgc2VsZi5zZW5kKHRydWUsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiBzZWxmLnNlbmQoZmFsc2UsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKSk7XG5cbn0pO1xuXG5zZWxmLmVtaXQgPSBmdW5jdGlvbiAoZGF0YSwgdGltZXN0YW1wLCBhY3Rpb24sIG1vZGVsKSB7XG4gICAgbGV0IGV2ID0gbmV3IHNlbGYuQ3VzdG9tRXZlbnQoJ2lkYjp3b3JrZXI6JyArIGFjdGlvbiwge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGRldGFpbDogZGF0YSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBtb2RlbDogbW9kZWxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2KTtcbn07XG5cbnNlbGYuc2VuZCA9IGZ1bmN0aW9uIChkYXRhLCB0aW1lc3RhbXAsIGFjdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IGV2ID0ge1xuICAgICAgICBkZXRhaWw6IGRhdGEsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICB9O1xuXG4gICAgc2VsZi5wb3N0TWVzc2FnZShldik7XG59O1xuXG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjpjcmVhdGUnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IG0gPSBtb2RlbHNbZS5kZXRhaWwubW9kZWxdO1xuXG4gICAgbS5jcmVhdGUoZS5kZXRhaWwuZGV0YWlsKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2lkYjp3b3JrZXI6ZmluZCcsIChlKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgbSA9IG1vZGVsc1tlLmRldGFpbC5tb2RlbF07XG4gICAgbS5idWlsZGVyID0gZS5kZXRhaWwuZGV0YWlsLmJ1aWxkZXI7XG4gICAgbS5pbmRleEJ1aWxkZXIgPSBlLmRldGFpbC5kZXRhaWwuaW5kZXhCdWlsZGVyO1xuICAgIG0udGFibGVzID0gZS5kZXRhaWwuZGV0YWlsLnRhYmxlcztcbiAgICBtLnJlbGF0aW9ucyA9IGUuZGV0YWlsLmRldGFpbC5yZWxhdGlvbnM7XG5cbiAgICBtLmZpbmQoZS5kZXRhaWwuZGV0YWlsKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2lkYjp3b3JrZXI6Y3JlYXRlTXVsdGlwbGUnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IG0gPSBtb2RlbHNbZS5kZXRhaWwubW9kZWxdO1xuICAgIG0uY3JlYXRlTXVsdGlwbGUoZS5kZXRhaWwuZGV0YWlsKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2lkYjp3b3JrZXI6Z2V0JywgKGUpID0+IHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGxldCBtID0gbW9kZWxzW2UuZGV0YWlsLm1vZGVsXTtcbiAgICBtLmJ1aWxkZXIgPSBlLmRldGFpbC5kZXRhaWwuYnVpbGRlcjtcbiAgICBtLmluZGV4QnVpbGRlciA9IGUuZGV0YWlsLmRldGFpbC5pbmRleEJ1aWxkZXI7XG4gICAgbS50YWJsZXMgPSBlLmRldGFpbC5kZXRhaWwudGFibGVzO1xuICAgIG0ucmVsYXRpb25zID0gZS5kZXRhaWwuZGV0YWlsLnJlbGF0aW9ucztcblxuICAgIG0uZ2V0KGUuZGV0YWlsLmRldGFpbClcbiAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5zZW5kKHJlc3VsdCwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXIgPT4ge1xuICAgICAgICAgICAgc2VsZi5zZW5kKGVyLCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbiArIGVycm9yTmFtZXNwYWNlKTtcbiAgICAgICAgfSk7XG59KTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdpZGI6d29ya2VyOmZpcnN0JywgKGUpID0+IHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGxldCBtID0gbW9kZWxzW2UuZGV0YWlsLm1vZGVsXTtcbiAgICBtLmJ1aWxkZXIgPSBlLmRldGFpbC5kZXRhaWwuYnVpbGRlcjtcbiAgICBtLmluZGV4QnVpbGRlciA9IGUuZGV0YWlsLmRldGFpbC5pbmRleEJ1aWxkZXI7XG4gICAgbS50YWJsZXMgPSBlLmRldGFpbC5kZXRhaWwudGFibGVzO1xuICAgIG0ucmVsYXRpb25zID0gZS5kZXRhaWwuZGV0YWlsLnJlbGF0aW9ucztcblxuICAgIG0uZmlyc3QoZS5kZXRhaWwuZGV0YWlsKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgc2VsZi5zZW5kKGVyciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjp1cGRhdGUnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IG0gPSBtb2RlbHNbZS5kZXRhaWwubW9kZWxdO1xuXG4gICAgbS51cGRhdGUoZS5kZXRhaWwuZGV0YWlsKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2lkYjp3b3JrZXI6c2F2ZScsIChlKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgbSA9IG1vZGVsc1tlLmRldGFpbC5tb2RlbF07XG5cbiAgICBtLnNhdmUoZS5kZXRhaWwuZGV0YWlsLmlkLCBlLmRldGFpbC5kZXRhaWwuZGF0YSlcbiAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5zZW5kKHJlc3VsdCwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXIgPT4ge1xuICAgICAgICAgICAgc2VsZi5zZW5kKGVyLCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbiArIGVycm9yTmFtZXNwYWNlKTtcbiAgICAgICAgfSk7XG59KTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdpZGI6d29ya2VyOmNvdW50JywgKGUpID0+IHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGxldCBtID0gbW9kZWxzW2UuZGV0YWlsLm1vZGVsXTtcblxuICAgIG0uY291bnQoKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2lkYjp3b3JrZXI6YXZlcmFnZScsIChlKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgbSA9IG1vZGVsc1tlLmRldGFpbC5tb2RlbF07XG5cbiAgICBtLmF2ZXJhZ2UoZS5kZXRhaWwuZGV0YWlsKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuXG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjpyZWR1Y2UnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IG0gPSBtb2RlbHNbZS5kZXRhaWwubW9kZWxdO1xuXG4gICAgbS5yZWR1Y2UoZS5kZXRhaWwuZGV0YWlsLmZ1bmMsIGUuZGV0YWlsLmRldGFpbC5kZWZhdWx0Q2FycnkpXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChyZXN1bHQsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2VuZChlciwgZS5kZXRhaWwudGltZXN0YW1wLCBlLmRldGFpbC5hY3Rpb24gKyBlcnJvck5hbWVzcGFjZSk7XG4gICAgICAgIH0pO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaWRiOndvcmtlcjpkZXN0cm95SWQnLCAoZSkgPT4ge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IG0gPSBtb2RlbHNbZS5kZXRhaWwubW9kZWxdO1xuXG4gICAgbS5kZXN0cm95SWQoZS5kZXRhaWwuZGV0YWlsKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2lkYjp3b3JrZXI6ZGVzdHJveScsIChlKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBsZXQgbSA9IG1vZGVsc1tlLmRldGFpbC5tb2RlbF07XG5cbiAgICBtLmRlc3Ryb3koKVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQocmVzdWx0LCBlLmRldGFpbC50aW1lc3RhbXAsIGUuZGV0YWlsLmFjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlciA9PiB7XG4gICAgICAgICAgICBzZWxmLnNlbmQoZXIsIGUuZGV0YWlsLnRpbWVzdGFtcCwgZS5kZXRhaWwuYWN0aW9uICsgZXJyb3JOYW1lc3BhY2UpO1xuICAgICAgICB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLmpzLm1hcFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGJ1aWxkL3dvcmtlci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBREE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7OztBQWw2QkE7QUFDQTtBQW82QkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ]);